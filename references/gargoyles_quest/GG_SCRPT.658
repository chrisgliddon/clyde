;------------------
;
;GG_SCRIPT.658
;
;  THE SCRIPT HANDLER CAN EXECUTE A SERIES OF PROGRAMMED COMMANDS WHEN
;CALLED. IT IS USED PRIMARILY TO SETUP LEVELS, SCREENS...
;
;
;------------------
;EQUATES

;-----
;DRAW_SCRN EQUATES

DS_SCRN	EQU	0	;SCREEN #
DS_MAPADD	EQU	2	;MAP ADDRESS
DS_MAPPAGE	EQU	4	;MAP PAGE
DS_MAPSIZE	EQU	5	;MAP SIZE
DS_MAPW	EQU	7	;MAP WIDTH
DS_MAPH	EQU	9	;MAP HEIGTH
DS_BLKADD	EQU	11	;BLOCK ADDRESS
DS_BLKPAGE	EQU	13	;BLOCK PAGE
DS_BLKSIZE	EQU	14	;BLOCK SIZE
DS_SCRNX	EQU	16	;SCREEN X
DS_SCRNY	EQU	18	;SCREEN Y
DS_END	EQU	20	;SIZE OF DATA AREA

;-----
;INIT_MAP EQUATES

IM_SCRN	EQU	0	;SCREEN #
IM_MAPX	EQU	2	;SCREEN X
IM_MAPY	EQU	4	;SCREEN Y
IM_MAPW	EQU	6	;MAP WIDTH
IM_MAPH	EQU	8	;MAP HEIGTH
IM_MAPSCROLL	EQU	10	;SCROLL FLAG
IM_MAPADD	EQU	11	;MAP ADDRESS
IM_MAPPAGE	EQU	13	;MAP PAGE
IM_MAPSIZE	EQU	14	;MAP SIZE

AM_END	EQU	16	;SIZE OF ADD A MAP DATA AREA

IM_BLKADD	EQU	16	;BLOCK ADDRESS
IM_BLKPAGE	EQU	18	;BLOCK PAGE
IM_BLKSIZE	EQU	19	;BLOCK SIZE
IM_FLRADD	EQU	21	;FLOOR ADDRESS
IM_FLRPAGE	EQU	23	;FLOOR PAGE
IM_CONADD	EQU	24	;CONTOUR ADDRESS
IM_CONPAGE	EQU	26	;CONTOUR PAGE
IM_END	EQU	27	;SIZE OF DATA AREA

;-----
;SET PLAYER X,Y

P_X	EQU	0	;PLAYER'S X
P_Y	EQU	2	;PLAYER'S Y
PXY_END	EQU	4

;------------------
;SCRIPT ROUTINE TABLE

SCRIPT_TABLE	DW	0
	DW	DO_SC_PAL	;1 = COPY DATA TO PALETTE
	DW	DO_SC_VRAM	;2 = COPY DATA TO VRAM
	DW	SET_JPH    	;3 = SET THE JOYPAD HANDLER
	DW	INIT_LVL   	;4 = INITIALIZE A GAME LEVEL
	DW	TURN_SC_ON	;5 = TURN SCREEN ON
	DW	DO_SC_JSL	;6 = CALL LONG ROUTINE
	DW	DRAW_SCRN	;7 = DRAW A SCREEN
	DW	INIT_MAP   	;8 = INIT A MAP
	DW	SET_PLAYER	;9 = SET THE PLAYER X,Y
	DW	DO_CLR_BKGD	;10 = CLEAR A BKGD
	DW	DO_CLR_VRAM	;11 = CLEAR ALL OF VRAM
	DW	DO_CLR_SCRN	;12 = CLEAR SCRN_BUF
	DW	SET_SCH	;13 = SET SCROLL HANDLER ROUTINE
	DW	DCMP_2_VRAM	;14 = DECOMPRESS DATA TO VRAM
	DW	ADD_AMAP	;15 = ADD JUST A MAP TO RAM
	DW	CUSTOM_MAP	;16 = CUSTOM MAP

;------------------
;SCRIPTS

;=====
;DISNEY LOGO SCRIPT

DISNEY_SCRIPT	SC_JSL	RESET_RAM		;RESET RAM ALLOCATION

	SC_LVL	MODE7_LVD		;INIT LEVEL DATA

	SC_PAL	MODE7_PAL,0*16,32*16	;COPY PALETTE TO CG-RAM

	SC_VRAM	MODE7_DATA1,&
		0,MODE7_SZ1 		;COPY LVL1 TILES TO VRAM

	SC_JPH	DISNEY_JPL		;SET JOYPAD HANDLER

	SC_SCH	NULL_SCROLL		;SET SCROLL HANDLER ROUTINE

	SC_JSL	INIT_DISNEY		;INIT THE MODE7 HANDLER

	SC_ON			;TURN SCREEN ON NOW

	SC_JSL	FADE_IN		;START FADE IN

	SC_END

;=====
;TITLE SCRIPT

TTL_SCRIPT	SC_JSL	RESET_RAM		;RESET RAM ALLOCATION
	
	SC_JSL	CLEAR_SPRITES		;REMOVE ALL SPRITES FROM SCRN

	SC_LVL	TITLE_LVD		;INIT LEVEL DATA

	SC_CLRV			;CLEAR ALL OF VRAM

	SC_PAL	TTL_PAL,0*16,32*1	;COPY TITLE PAL TO PAL #0

	SC_VRAM	TTL_CHAR,0,TTL_CHR_SZ	;COPY TITLE SCREEN TO VRAM

	SC_PAL	PAL2,1*16,32*1		;COPY TEXT PAL TO PAL #1

	SC_VRAM	FONT1,$6000,96*32	;COPY FONT INTO VRAM

	SC_JPH	TITLE_JPL		;SET JOYPAD HANDLER

	SC_SCH	SCROLL_OFF		;SET SCROLL HANDLER ROUTINE

	SC_SCRN	&		;DRAW TITLE SCREEN
		2,&		;BKGD # TO USE
		TTL_MAP,16,16,&		;MAP ADDRESS. X,Y SIZE
		TTL_BLOCK,TTL_BLK_SZ,&	;BLOCK ADDRESS. BLOCK SIZE
		0,0		;SCREEN X,Y

	SC_CLR_SB		;CLEAR SCRN_BUF

	SC_JSL	DO_MAIN_MENU		;DISPLAY LEVEL MENU


	SC_ON			;TURN SCREEN ON NOW

	SC_JSL	FADE_IN		;START FADE IN

	SC_JSL	TEST_DCMP

	SC_END

;=====
;LEVEL 1 SETUP SCRIPT

LVL1_SCRIPT	SC_JSL	RESET_RAM		;RESET RAM ALLOCATION

	SC_LVL	LVL1_LVD		;INIT LEVEL DATA

	SC_PAL	LVL1_PAL,0*16,32*7	;COPY LVL1 PALETTE TO CG-RAM

	SC_DCVR	LVL1_CHAR,&
		0,LVL1_CHR_SZ 		;COPY LVL1 TILES TO VRAM

	SC_JPH	LVL1_JPL		;SET JOYPAD HANDLER

	SC_SCH	CK_SCROLL		;SET SCROLL HANDLER ROUTINE

	SC_CMP	&		;DRAW LEVEL 1 CUSTOM MAP
		1,&		;BKGD # TO USE
		$0,$40A,128,70,&		;MAP START X,Y. X,Y SIZE
		2,&		;SCREEN SCROLLING ONLY
		LVL1_MAP,&		;MAP ADDRESS
		LVL1_BLOCK,&		;BLOCK ADDRESS.
		LVL1_BLK_SZ,&		;BLOCK SIZE
		LVL1_FLR,&		;FLOOR ADDRESS
		CONTOUR1		;CONTOUR ADDRESS

	SC_PAL	GOL_RUN_PAL,8*16,32*1	;COPY LVL1 PALETTE TO CG-RAM

	SC_JSL	INIT_GOLIATH		;START UP GOLIATH

;	SC_PAL	VI_WALK_PAL,9*16,32*1	;COPY LVL1 PALETTE TO CG-RAM
	SC_PAL	AR_SHOT_PAL,9*16,32*1	;COPY LVL1 PALETTE TO CG-RAM
            
;	SC_JSL	INIT_VI

;	SC_JSL	READ_CG		;READ PALETTE DATA BACK

;	SC_JSL	CC_TEST	;TEST COLOR CYCLE

	SC_ON			;TURN SCREEN ON NOW

	SC_JSL	FADE_IN		;START FADE IN

	SC_END

;=====
;LEVEL 2 SETUP SCRIPT

LVL2_SCRIPT	SC_JSL	RESET_RAM		;RESET RAM ALLOCATION

	SC_LVL	LVL1_LVD		;INIT LEVEL DATA

	SC_PAL	LVL2_PAL,0*16,32*7	;COPY LVL1 PALETTE TO CG-RAM

	SC_DCVR	LVL2_CHAR,&
		0,LVL2_CHR_SZ 		;COPY LVL1 TILES TO VRAM

	SC_JPH	LVL1_JPL		;SET JOYPAD HANDLER

	SC_SCH	CK_SCROLL		;SET SCROLL HANDLER ROUTINE

	SC_MAP	&		;DRAW LEVEL 1 MAP
		1,&		;BKGD # TO USE
		$4BA,$679,80,126,&		;MAP START X,Y. X,Y SIZE
		2,&		;SCREEN SCROLLING ONLY
		LVL2_MAP,&		;MAP ADDRESS
		LVL2_BLOCK,&		;BLOCK ADDRESS.
		LVL2_BLK_SZ,&		;BLOCK SIZE
		LVL2_FLR,&		;FLOOR ADDRESS
		CONTOUR1		;CONTOUR ADDRESS

	SC_PAL	GOL_RUN_PAL,8*16,32*1	;COPY LVL1 PALETTE TO CG-RAM

	SC_JSL	INIT_GOLIATH		;START UP GOLIATH

	SC_ON			;TURN SCREEN ON NOW

	SC_JSL	FADE_IN		;START FADE IN

	SC_END

;=====
;LEVEL 3 SETUP SCRIPT

LVL3_SCRIPT	SC_JSL	RESET_RAM		;RESET RAM ALLOCATION

	SC_LVL	LVL1_LVD		;INIT LEVEL DATA

	SC_PAL	LVL3_PAL,0*16,32*7	;COPY LVL1 PALETTE TO CG-RAM

	SC_DCVR	LVL3_CHAR,&
		0,LVL3_CHR_SZ 		;COPY LVL1 TILES TO VRAM

	SC_JPH	LVL1_JPL		;SET JOYPAD HANDLER

	SC_SCH	CK_SCROLL		;SET SCROLL HANDLER ROUTINE

	SC_MAP	&		;DRAW LEVEL 1 MAP
		1,&		;BKGD # TO USE
		$44F,$9E-$50,80,126,&		;MAP START X,Y. X,Y SIZE
		2,&		;SCREEN SCROLLING ONLY
		LVL3_MAP,&		;MAP ADDRESS
		LVL3_BLOCK,&		;BLOCK ADDRESS.
		LVL3_BLK_SZ,&		;BLOCK SIZE
		LVL3_FLR,&		;FLOOR ADDRESS
		CONTOUR1		;CONTOUR ADDRESS

	SC_PAL	GOL_RUN_PAL,8*16,32*1	;COPY LVL1 PALETTE TO CG-RAM

	SC_JSL	INIT_GOLIATH		;START UP GOLIATH

	SC_ON			;TURN SCREEN ON NOW

	SC_JSL	FADE_IN		;START FADE IN

	SC_END

;=====
;LEVEL 4 SETUP SCRIPT

LVL4_SCRIPT	SC_JSL	RESET_RAM		;RESET RAM ALLOCATION

	SC_LVL	LVL5_LVD		;INIT LEVEL DATA

	SC_PAL	LVL4_PAL,0*16,32*7	;COPY LVL1 PALETTE TO CG-RAM

	SC_DCVR	LVL4_CHAR,&		;COPY LVL1 TILES TO VRAM
		0,LVL4_CHR_SZ 		;@ $0000, SIZE

	SC_JPH	LVL1_JPL		;SET JOYPAD HANDLER

	SC_SCH	LVL5A_SCROLL		;SET SCROLL HANDLER ROUTINE

	SC_MAP	&		;DRAW LEVEL 1 MAP
		1,&		;BKGD # TO USE
		0,0,16,800,&		;MAP START X,Y. X,Y SIZE
		0,&		;SCREEN SCROLLING ONLY
		LVL4_MAP,&		;MAP ADDRESS
		LVL4_BLOCK,&		;BLOCK ADDRESS.
		LVL4_BLK_SZ,&	 	;BLOCK SIZE
		LVL4_FLR,&		;FLOOR ADDRESS
		CONTOUR1		;CONTOUR ADDRESS

	SC_MAP	&		;DRAW LEVEL 1 MAP
		2,&		;BKGD # TO USE
		0,0,16,800,&		;MAP START X,Y. X,Y SIZE
		2,&		;SCREEN SCROLLING ONLY
		LVL4_MAP2,&		;MAP ADDRESS
           		LVL4_BLOCK,&		;BLOCK ADDRESS.
		LVL4_BLK_SZ,&	 	;BLOCK SIZE
		LVL4_FLR,&		;FLOOR ADDRESS
		CONTOUR1		;CONTOUR ADDRESS

	SC_PAL	GOL_RUN_PAL,8*16,32*1	;COPY LVL1 PALETTE TO CG-RAM

	SC_JSL	INIT_GOLIATH		;START UP GOLIATH

	SC_JSL	INIT_SCRL5		;INIT THE LEVEL 5 SCROLL

	SC_JSL	NEW_SONG

	SC_ON			;TURN SCREEN ON NOW

	SC_JSL	FADE_IN		;START FADE IN

	SC_END
;=====
;LEVEL 5 SETUP SCRIPT

LVL5_SCRIPT	SC_JSL	RESET_RAM		;RESET RAM ALLOCATION

	SC_LVL	LVL1_LVD		;INIT LEVEL DATA

	SC_PAL	LVL5_PAL,0*16,32*7	;COPY LVL1 PALETTE TO CG-RAM

	SC_DCVR	LVL5_CHAR,&
		0,LVL5_CHR_SZ 		;COPY LVL1 TILES TO VRAM

	SC_JPH	LVL1_JPL		;SET JOYPAD HANDLER

	SC_SCH	CK_SCROLL		;SET SCROLL HANDLER ROUTINE

	SC_MAP	&		;DRAW LEVEL 1 MAP
		1,&		;BKGD # TO USE
		$0,$40A,144,70,&		;MAP START X,Y. X,Y SIZE
		2,&		;SCREEN SCROLLING ONLY
		LVL5_MAP,&		;MAP ADDRESS
		LVL5_BLOCK,&		;BLOCK ADDRESS.
		LVL5_BLK_SZ,&		;BLOCK SIZE
		LVL5_FLR,&		;FLOOR ADDRESS
		CONTOUR1		;CONTOUR ADDRESS

	SC_PAL	GOL_RUN_PAL,8*16,32*1	;COPY LVL1 PALETTE TO CG-RAM

	SC_JSL	INIT_GOLIATH		;START UP GOLIATH

	SC_ON			;TURN SCREEN ON NOW

	SC_JSL	FADE_IN		;START FADE IN

	SC_END

;=====
;LEVEL 6 SETUP SCRIPT

LVL6_SCRIPT	SC_JSL	RESET_RAM		;RESET RAM ALLOCATION

	SC_LVL	LVL5B_LVD		;INIT LEVEL DATA

	SC_PAL	LVL6_PAL,0*16,32*7	;COPY LVL1 PALETTE TO CG-RAM

	SC_DCVR	LVL6_CHAR,&
		0,LVL6_CHR_SZ	 	;COPY LVL1 TILES TO VRAM

	SC_JPH	LVL1_JPL		;SET JOYPAD HANDLER

	SC_SCH	LVL5B_SCROLL		;SET SCROLL HANDLER ROUTINE

	SC_MAP	&		;DRAW LEVEL MAP
		1,&		;BKGD # TO USE
		0,0,128,32,&		;MAP START X,Y. X,Y SIZE
		2,&		;SCREEN SCROLLING ONLY
		LVL6_MAPB,&		;MAP ADDRESS
		LVL6_BLOCK,&		;BLOCK ADDRESS. 
		LVL6_BLK_SZ,&		;BLOCK SIZE
		LVL6_FLR,&		;FLOOR ADDRESS
		CONTOUR1		;CONTOUR ADDRESS

	SC_AAM	&		;ADD LEVEL MAP
		2,&		;BKGD # TO USE
		0,0,32,16,&		;MAP START X,Y. X,Y SIZE
		0,&		;SCREEN SCROLLING ONLY
		LVL6_MAP		;MAP ADDRESS

	SC_PAL	GOL_RUN_PAL,8*16,32*1	;COPY LVL1 PALETTE TO CG-RAM

	SC_JSL	INIT_GOLIATH		;START UP GOLIATH

	SC_JSL	TEST_HDMA

	SC_ON			;TURN SCREEN ON NOW

	SC_JSL	FADE_IN		;START FADE IN

	SC_END




;=====
;MODE 7 TEST SETUP SCRIPT

MODE7_SCRIPT	SC_JSL	RESET_RAM		;RESET RAM ALLOCATION

	SC_LVL	MODE7_LVD		;INIT LEVEL DATA

	SC_PAL	MODE7_PAL,0*16,32*16	;COPY PALETTE TO CG-RAM

	SC_VRAM	MODE7_DATA1,&
		0,MODE7_SZ1 		;COPY LVL1 TILES TO VRAM

	SC_JPH	MODE7_JPL		;SET JOYPAD HANDLER

	SC_SCH	NULL_SCROLL		;SET SCROLL HANDLER ROUTINE

	SC_JSL	INIT_MODE7		;INIT THE MODE7 HANDLER

	SC_ON			;TURN SCREEN ON NOW

	SC_JSL	FADE_IN		;START FADE IN

	SC_END











;=====
;LEVEL 7 SETUP SCRIPT

LVL7_SCRIPT	SC_JSL	RESET_RAM		;RESET RAM ALLOCATION

	SC_LVL	LVL1_LVD		;INIT LEVEL DATA

	SC_PAL	LVL7_PAL,0*16,32*7	;COPY LVL1 PALETTE TO CG-RAM

	SC_DCVR	LVL7_CHAR,&
		0,LVL7_CHR_SZ	 	;COPY LVL1 TILES TO VRAM

	SC_JPH	LVL1_JPL		;SET JOYPAD HANDLER

	SC_SCH	CK_SCROLL		;SET SCROLL HANDLER ROUTINE

	SC_MAP	&		;DRAW LEVEL 1 MAP
		1,&		;BKGD # TO USE
		0,$73A,80,126,&		;MAP START X,Y. X,Y SIZE
		2,&		;SCREEN SCROLLING ONLY
		LVL7_MAP,&		;MAP ADDRESS
		LVL7_BLOCK,&		;BLOCK ADDRESS.
		LVL7_BLK_SZ,&		;BLOCK SIZE
		LVL7_FLR,&		;FLOOR ADDRESS
		CONTOUR1		;CONTOUR ADDRESS

;	SC_PXY	128,128		;SET THE PLAYER X,Y

	SC_PAL	GOL_RUN_PAL,8*16,32*1	;COPY LVL1 PALETTE TO CG-RAM

	SC_JSL	INIT_GOLIATH		;START UP GOLIATH

	SC_ON			;TURN SCREEN ON NOW

	SC_JSL	FADE_IN		;START FADE IN

	SC_END





;=====
;BUNUS LEVEL SETUP SCRIPT

BONUS_SCRIPT	SC_JSL	RESET_RAM		;RESET RAM ALLOCATION

	SC_LVL	LVL1_LVD		;INIT LEVEL DATA

	SC_PAL	BONUS_PAL,0*16,32*7	;COPY BONUS PALETTE TO CG-RAM

	SC_DCVR	BONUS_CHAR,&
		0,BONUS_CHR_SZ 		;COPY BONUS TILES TO VRAM

	SC_JPH	LVL1_JPL		;SET JOYPAD HANDLER

	SC_SCH	CK_SCROLL		;SET SCROLL HANDLER ROUTINE

	SC_CMP	&		;DRAW LEVEL 1 CUSTOM MAP
		1,&		;BKGD # TO USE
		$0,$0,16,16,&		;MAP START X,Y. X,Y SIZE
		2,&		;SCREEN SCROLLING ONLY
		BONUS_MAP,&		;MAP ADDRESS
		BONUS_BLOCK,&		;BLOCK ADDRESS.
		BONUS_BLK_SZ,&		;BLOCK SIZE
		BONUS_FLR,&		;FLOOR ADDRESS
		CONTOUR1		;CONTOUR ADDRESS

	SC_JSL	CA_TEST

	SC_ON			;TURN SCREEN ON NOW

	SC_JSL	FADE_IN		;START FADE IN

	SC_END













;------------------
;DO_SCRIPT -- EXECUTE SCRIPT COMMAND 
;
;	DB,Y -- ADDRESS OF SCRIPT TO EXECUTE

;-----
;SCRIPT COMMANDS

SC_END_CODE	EQU	0	;END OF SCRIPT

;-----

DO_SCRIPT	MODULE

	PHP
DS_LP:
	SET_AXY16
	LDA	#0	;CLEAR MSB
	SET_A8
	LDA	$0,Y	;GET A COMMAND
	CMP	#SC_END_CODE	;END OF SCRIPT ?
	BEQ	DS_DONE
	INY
	ASL		;WORD POINTER
	TAX
	JSR	(SCRIPT_TABLE,X)
	JMP	DS_LP
;-----
DS_DONE	PLP
	RTL

	MODEND

;------------------
;DO_SC_PAL -- DMA COLOR DATA TO PALETTE

DO_SC_PAL	MODULE

	PHP
	PHB		;SAVE CURRENT BANK
	SET_A8
;
	STZ	MDMAEN	;CLEAR DMA CHANNEL
	LDA	#$00
	STA	WDMAP0	;DMA PARAMETER DATA FOR CHANNEL 0
	LDA	#<WCGDATA	;WRITE TO HERE
	STA	BADMA0
;
	LDA	$0,Y	;GET ADDRESS OF PALETTE
	INY
	STA	A1ADMAL0	;LOW
	LDA	$0,Y
	INY
	STA	A1ADMAH0	;HIGH
;
	LDA	$0,Y	;GET DATA BANK OF PALETTE
	INY
	STA	A1ADMAB0	;BANK
;
	LDA	$0,Y	;GET DEST ADDRESS IN PALETTE
	INY
	STA	CGADD	;SET WRITE ADDRESS
;
	LDA	$0,Y	;# OF BYTES TO SEND
	INY
	STA	DMADATL0	;LOW
	LDA	$0,Y	;# OF BYTES TO SEND
	INY
	STA	DMADATH0	;HIGH
;
	LDA	#1
	STA	MDMAEN	;START DMA
;	
	PLB	
	PLP
	RTS	

	MODEND
;------------------
;DO_SC_VRAM -- DMA DATA INTO VRAM

DO_SC_VRAM	MODULE

	PHP
	PHB		;SAVE CURRENT BANK
	SET_A8
;
	LDA	#$80
	STA	VMAINC
;
	STZ	MDMAEN	;CLEAR DMA CHANNEL
	LDA	#$01
	STA	WDMAP0	;DMA PARAMETER DATA FOR CHANNEL 0
	LDA	#<WVMDATAL	;WRITE TO HERE
	STA	BADMA0
;
	LDA	$0,Y	;GET ADDRESS OF SOURCE
	INY
	STA	A1ADMAL0	;LOW
	LDA	$0,Y
	INY
	STA	A1ADMAH0	;HIGH
;
	LDA	$0,Y	;GET DATA BANK OF SOURCE
	INY
	STA	A1ADMAB0	;BANK
;
	SET_A16
	LDA	$0,Y	;GET DEST ADDRESS IN VRAM
	INY
	INY
	STA	VMADDL	;SET VRAM WRITE ADDRESS
;
	LDA	$0,Y	;# OF BYTES TO SEND
	INY
	INY
	SET_A8
	STA	DMADATL0	;LOW
	XBA
	STA	DMADATH0	;HIGH
;
	LDA	#1
	STA	MDMAEN	;START DMA
;	
	PLB	
	PLP
	RTS	

	MODEND

;------------------
;DCMP_2_VRAM -- DECOMPRESS DATA INTO VRAM

DCMP_2_VRAM	MODULE

	PHP
	PHB		;SAVE CURRENT BANK
	SET_A16
;-----
;FIRST DECOMPRESS THE DATA INTO WORK RAM
	LDA	$0,Y	;GET ADDRESS OF SOURCE
	INY
	INY
	STA	DCMP_SRC	;SET SOURCE OFFSET
;-----
	LDA	#0
	SET_A8
	LDA	$0,Y	;GET DATA BANK OF SOURCE
	INY
	STA	DCMP_SRC+2	;SET SOURCE BANK
;-----
	SET_A16
	LDA	$0,Y	;GET DEST ADDRESS IN VRAM
	INY
	INY
	STA	VMADDL	;SET VRAM WRITE ADDRESS
;-----
	LDA	$0,Y	;# OF BYTES TO SEND
	INY
	INY		;NOT USED
;-----
 	LDA	NEXT_RAM
	STA	DCMP_DEST
	LDA	NEXT_RAM+2
	STA	DCMP_DEST+2
	PHY		;SAVE POINTER
	JSL	DECOMPRESS	;DECOMPRESS THE DATA
	PLY
	STA	TEMP_X	;SAVE DECOMPRESSED SIZE
;-----
	SET_A8
	LDA	#$80
	STA	VMAINC
;
	STZ	MDMAEN	;CLEAR DMA CHANNEL
	LDA	#$01
	STA	WDMAP0	;DMA PARAMETER DATA FOR CHANNEL 0
	LDA	#<WVMDATAL	;WRITE TO HERE
	STA	BADMA0
;
	LDA	DCMP_DEST	;GET ADDRESS OF SOURCE
	STA	A1ADMAL0	;LOW
	LDA	DCMP_DEST+1
	STA	A1ADMAH0	;HIGH
;
	LDA	DCMP_DEST+2	;GET DATA BANK OF SOURCE
	STA	A1ADMAB0	;BANK
;
	SET_A16
	LDA	TEMP_X	;GET SIZE
	SET_A8
	STA	DMADATL0	;LOW
	XBA
	STA	DMADATH0	;HIGH
;
	LDA	#1
	STA	MDMAEN	;START DMA
;	
	PLB	
	PLP
	RTS	

	MODEND


;------------------
;SET_JPH -- SET THE ADDRESS OF THE JOYPAD HANDLER

SET_JPH	MODULE

	PHP
;
	SET_A16
	LDA	$0,Y	;GET ADDRESS OF JP LIST
	INY
	INY
	STA	JP_LIST	;GET ADDRESS
	SET_A8
	LDA	$0,Y
	INY
	STA	JP_LIST+2	;SET BANK
;
	PLP
	RTS


	MODEND

;------------------
;INIT_LVL -- INITIALIZE A GAME LEVEL

INIT_LVL	MODULE

	PHP
	PHB
	PHY
;-----
	SET_A16
	LDA	$0,Y	;GET ADDRESS OF LEVEL DATA
	TAX
	SET_A8
	LDA	$2,Y	;GET BANK OF LEVEL DATA
	PHA
	PLB
	TXY
;-----
;SET OBJSEL = $2101

	SET_A16
	STZ	TEMP_WORD	;CLEAR TEMP AREA
	LDA	$0,Y	;GET OBJ BASE ADDRESS
	STA	OBJ_BASE
	CLC
	ROL	A
	ROL	A
	ROL	A
	ROL	A	;ADJUST FOR 
	SET_A8
	AND	#$07
	STA	TEMP_WORD
;
	LDA	$2,Y	;GET OBJ DATA AREA
	STA	OBJ_AREA
	ASL	A
	ASL	A
	ASL	A
	AND	#$18	;MASK IT
	ORA	TEMP_WORD	;COMBINE
	STA	TEMP_WORD	;SAVE
;
	LDA	$3,Y	;GET OBJ SIZES
	STA	OBJ_SIZE
	CLC
	ROR	A
	ROR	A
	ROR	A
	ROR	A
	AND	#$E0	;MASK IT
	ORA	TEMP_WORD
	STA	OBJSEL	;SET HARDWARE REGISTER
;-----
;SET BGMODE = $2105

	LDA	$4,Y	;GET SCREEN MODE
	STA	SC_MODE
	AND	#$07	;MASK IT
	STA	TEMP_WORD
;
	LDA	$5,Y	;GET BG 3 PRIORITY
	STA	BG3_PRIO
	ASL	A
	ASL	A
	ASL	A	;ADJUST IT
	AND	#$08	;MASK IT
	ORA	TEMP_WORD	;COMBINE
	STA	TEMP_WORD	;SAVE IT
;
	LDA	$6,Y	;GET BG CHAR SIZE
	STA	BG_CSIZE
	ASL	A
	ASL	A
	ASL	A
	ASL	A
	AND	#$F0	;MASK IT
	ORA	TEMP_WORD	;COMBINE IT
	STA	BGMODE	;SET HARDWARE REGISTER
;-----
;SET BG1SC = $2107

	LDA	$7,Y	;GET BG1 SCREEN SIZE
	STA	BG1_SIZE
	AND	#$03	;MASK IT
	STA	TEMP_WORD
;
	SET_A16
	LDA	$8,Y	;GET BG1 SC BASE ADDRESS
	STA	BG1_SC
	XBA
	SET_A8
	AND	#$FC	;MASK IT
	ORA	TEMP_WORD
	STA	BG1SC	;SET HARDWARE REGISTER
;-----
;SET BG2SC = $2108

	LDA	$A,Y	;GET BG2 SCREEN SIZE
	STA	BG2_SIZE
	AND	#$03	;MASK IT
	STA	TEMP_WORD
;
	SET_A16
	LDA	$B,Y	;GET BG2 SC BASE ADDRESS
	STA	BG2_SC
	XBA
	SET_A8
	AND	#$FC	;MASK IT
	ORA	TEMP_WORD
	STA	BG2SC	;SET HARDWARE REGISTER
;-----
;SET BG3SC = $2109

	LDA	$D,Y	;GET BG3 SCREEN SIZE
	STA	BG3_SIZE
	AND	#$03	;MASK IT
	STA	TEMP_WORD
;
	SET_A16
	LDA	$E,Y	;GET BG3 SC BASE ADDRESS
	STA	BG3_SC
	XBA
	SET_A8
	AND	#$FC	;MASK IT
	ORA	TEMP_WORD
	STA	BG3SC	;SET HARDWARE REGISTER
;-----
;SET BG4SC = $210A

	LDA	$10,Y	;GET BG4 SCREEN SIZE
	STA	BG4_SIZE
	AND	#$03	;MASK IT
	STA	TEMP_WORD
;
	SET_A16
	LDA	$11,Y	;GET BG4 SC BASE ADDRESS
	STA	BG4_SC
	XBA
	SET_A8
	AND	#$FC	;MASK IT
	ORA	TEMP_WORD
	STA	BG4SC	;SET HARDWARE REGISTER
;-----
;SET BG12NBA = $210B

	SET_A16
	LDA	$13,Y	;GET BG 1 CHAR DATA BASE ADDRESS
	STA	BG1_CHAR
	SET_A8
	XBA
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	AND	#$0F
	STA	TEMP_WORD
	SET_A16
	LDA	$15,Y	;GET BG 2 CHAR DATA BASE ADDRESS
	STA	BG2_CHAR
	SET_A8
	XBA
	AND	#$F0	;MASK IT
	ORA	TEMP_WORD
	STA	BG12NBA	;SET HARDWARE REGISTER
;-----
;SET BG34NBA = $210C

	SET_A16
	LDA	$17,Y	;GET BG 3 CHAR DATA BASE ADDRESS
	STA	BG3_CHAR
	SET_A8
	XBA
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	AND	#$0F
	STA	TEMP_WORD
	SET_A16
	LDA	$19,Y	;GET BG 4 CHAR DATA BASE ADDRESS
	STA	BG4_CHAR
	SET_A8
	XBA
	AND	#$F0	;MASK IT
	ORA	TEMP_WORD
	STA	BG34NBA	;SET HARDWARE REGISTER
;-----
;GET BUT DON'T SET TM
	LDA	$1B,Y	;GET MAIN SCREEN DESIGNATION
	STA	TM_VALUE
;-----
	SET_AXY16
	PLA
	CLC
	ADC	#3	;SKIP ADDRESS
	TAY
	PLB
	PLP
	RTS


	MODEND

;------------------
;TURN_SC_ON -- TURN THE SCREEN ON NOW

TURN_SC_ON	MODULE

	PHP
	SET_A8
;-----
	LDA	TM_VALUE
	STA	TM	;ENABLE SCREENS
;-----
;RELEASE FORCED BLANK
	LDA	#$00	;ENABLE DISPLAY BUT BRIGHTNESS = 0
	STA	INIDISP
;-----
;ENABLE "NMI ENABLE"
;ENABLE "JOY-C ENABLE"

	LDA	#$81
	STA	NMITIMEN	;ENABLE NMI 
	CLI   		;ENABLE INTERRUPTS
;-----
	PLP
	RTS

	MODEND

;------------------
;SET_SCH -- SET THE ADDRESS OF THE SCROLL HANDLER

SET_SCH	MODULE

	PHP
;
	SET_A16
	LDA	$0,Y	;GET ADDRESS OF SCROLL HANDLER
	INY
	INY
	STA	SCRL_HANDLER	;SET ADDRESS
	SET_A8
	LDA	$0,Y
	INY
	STA	SCRL_HANDLER+2	;SET BANK
;-----
;INIT SOME SCROLL STUFF
	SET_A16
	STZ	ERRORX
	STZ	ERRORY
	STZ	OPP_MAPX
	STZ	OPP_MAPY
	STZ	XSCROLL_DIR
	STZ	YSCROLL_DIR
	LDA	#1
	STA	XSCROLL_RATE
	STA	YSCROLL_RATE
	
	
;
	PLP
	RTS


	MODEND

;------------------
;DO_SC_JSL -- CALL A LONG ROUTINE

DO_SC_JSL	MODULE

	PHP
	PHB
	PHY
;-----
	PHK		;PUSH PROGRAM BANK
	PER	@RETURN-1	;SAVE RETURN ADDRESS
;
	SET_A8
	LDA	$2,Y	;GET BANK
	PHA		;PUSH PROGRAM BANK ADDRESS
	SET_A16
	LDA	$0,Y	;GET ADDRESS OF ROUTINE
	SEC
	SBC	#1
	PHA		;PUSH ADDRESS
	RTL		;GO THERE NOW
;-----
@RETURN	SET_AXY16
	PLA
	CLC
	ADC	#3
	TAY
	PLB
	PLP
	RTS

	MODEND

;------------------
;DRAW_SCRN -- DRAW A SCREEN INTO VRAM

DRAW_SCRN	MODULE

	PHP
	PHB
	SET_AXY16
	STY	SCRIPT_PTR	;SAVE POINTER
;-----
;GET SCREEN # AND MAKE POINTER
	LDA	DS_SCRN,Y	;GET SCREEN #
	DEC	A
	ASL	A
	STA	SCRN_PTR
	CLC
	ADC	$0,Y	;SCRN # * 3
	STA	SCRN_PTR3
;-----
;LOAD ALL THE DATA INTO VARIABLES
	LDA	DS_MAPADD,Y	;GET OFFSET OF MAP
	STA	MAP_IN_ROM	;SAVE OFFSET
	LDA	DS_BLKADD,Y	;GET OFFSET OF BLOCK
	STA	BLK_IN_ROM	;SAVE OFFSET
	SET_A8
	LDA	DS_MAPPAGE,Y	;GET BANK OF MAP
	STA	MAP_IN_ROM+2
	LDA	DS_BLKPAGE,Y	;GET BANK OF BLOCK
	STA	BLK_IN_ROM+2
	STZ	MAP1_SC_FLAG	;NO SCROLL
	STZ	MAP2_SC_FLAG	;NO SCROLL
	STZ	MAP3_SC_FLAG	;NO SCROLL
	STZ	MAP4_SC_FLAG	;NO SCROLL
	SET_A16
	LDA	DS_BLKSIZE,Y	;GET SIZE OF BLOCK DATA
	STA	BLK_BYTES	;SAVE FOR MOVE
	LDA	DS_MAPSIZE,Y	;GET MAP SIZE IN BYTES
	STA	MAP_BYTES	;SAVE FOR MOVE
;-----
;ALLOCATE RAM FOR MAP
	JSL	ALLOC_RAM	;ALLOCATE RAM
	LDX	SCRN_PTR	;GET SCREEN PTR
	STA	MAP1_HANDLE,X	;POINTER TO MAP RAM BLOCK
	STA	MAP_HANDLE	;SAVE IN TEMP HANDLE
;-----
;COPY MAP TO RAM
	LDX	MAP_HANDLE
	LDA	RAM_BLOCK0,X	;OFFSET OF AVAILABLE RAM
	STA	MAP_IN_RAM
	LDA	RAM_BLOCK0+2,X
	SET_A8
	STA	MAP_IN_RAM+2	;BANK OF RAM
;
	SET_A16
	JSR	MAP_2_RAM	;COPY MAP INTO WORK RAM
;-----
;ALLOCATE RAM FOR BLOCK DATA
	LDA	BLK_BYTES	;SIZE OF BLOCK
	JSL	ALLOC_RAM	;ALLOCATE RAM
	LDX	SCRN_PTR	;GET SCREEN PTR
	STA	BLK1_HANDLE,X	;POINTER TO MAP RAM BLOCK
	STA	BLK_HANDLE	;SAVE IN TEMP HANDLE
;-----
;COPY BLOCK TO RAM
	LDX	BLK_HANDLE
	LDA	RAM_BLOCK0,X	;OFFSET OF AVAILABLE RAM
	STA	BLK_IN_RAM
	LDA	RAM_BLOCK0+2,X
	SET_A8
	STA	BLK_IN_RAM+2	;BANK OF RAM
;
	SET_A16
	JSR	BLK_2_RAM	;COPY BLOCK TO WORK RAM
;-----
	JSL	CLR_SCRN_BUF	;CLEAR OUT THE SCRN_BUF
;-----
;FIGURE THE OFFSET INTO THE SCREEN BUF TO DRAW
LOOK_HERE	LDX	SCRN_PTR	;GET SCREEN #
	LDY	SCRIPT_PTR	;RESTORE SCRIPT POINTER
	LDA	DS_MAPW,Y	;GET MAP WIDTH
	STA	MAP_WIDTH
	STA	MAP1_WIDTH,X
	LDA	DS_MAPH,Y	;GET MAP HEIGTH
	STA	MAP_HEIGTH
	STA	MAP1_HEIGTH,X
	LDA	DS_SCRNY,Y	;GET SCREEN Y
	STA	SCRN_Y
	SET_A8
	STA	WRMPYA	;SET MULTIPLICAND
	LDA	#64	;WIDTH OF SCREEN
	STA	WRMPYB	;SET MULTIPLIER
	NOP
	NOP
	NOP
	NOP
	NOP		;WAIT 8 CYCLES
	LDA	RDMPYH	;GET HIGH
	XBA
	LDA	RDMPYL	;GET LOW
	SET_A16
	STA	SCRN_OFF	;SAVE IT
	LDA	DS_SCRNX,Y	;GET SCREEN X
	STA	SCRN_X	;SAVE START X
	CLC
	ADC	SCRN_OFF	;ADD SCRN X
	STA	SCRN_OFF	;SAVE IT
;-----
;NOW DRAW THE MAP INTO THE SCRN_BUF
	SET_A8
	LDA	#^SCRN_BUF
	PHA
	PLB    		;SET SCRN_BUF PAGE
	SET_A16
;
	LDY	#0	;AT BEGINNING
	LDA	MAP_HEIGTH
	STA	SCRN_HEIGTH	;SET COUNTER
;
@LOOP3	LDX	SCRN_OFF	;START NEW ROW
	LDA	MAP_WIDTH	;GET WIDTH
	STA	SCRN_WIDTH	;SET COUNTER
;
@LOOP4	LDA	[MAP_IN_RAM],Y	;GET A MAP REFERENCE
	INY
	INY
	PHY
	TAY
	AND	#$3C00
	STA	MAP_PC	;SAVE PRIORITY AND COLOR
	TYA
	AND	#$C000
	STA	MAP_FB	;SAVE FLIP BITS
	TYA
	AND	#$03FF	;JUST INDEX DATA
	ASL
	ASL
	ASL
	TAY		;POINT INTO BLOCK DATA
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY
	STA	T0	;SAVE TILE 0
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY
	STA	T1	;SAVE TILE 1
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY
	STA	T2	;SAVE TILE 2
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	STA	T3	;SAVE TILE 3
;-----
;TEST FLIP BITS AND ADJUST
	LDA	MAP_FB	;GET FLIP BITS
	BIT	#$4000	;X FLIP ?
	BEQ	NO_X_FLIP
	LDA	T0
	LDY	T1
	STA	T1
	STY	T0	;FLIP T0,T1
	LDA	T2
	LDY	T3
	STA	T3
	STY	T2	;FLIP T2,T3
;
NO_X_FLIP	LDA	MAP_FB	;GET FLIP BITS
	BIT	#$8000	;Y FLIP ?
	BEQ	NO_Y_FLIP
	LDA	T0
	LDY	T2
	STA	T2
	STY	T0	;FLIP T0,T2
	LDA	T1
	LDY	T3
	STA	T3
	STY	T1	;FLIP T1,T3
NO_Y_FLIP	PLY
;-----
;NOW STORE IT IN THE CORRECT LOCATION IN THE SCRN_BUF
	LDA	T0
	STA	SCRN_BUF,X	;SAVE TOP LEFT TILE
	LDA	T1
	STA	SCRN_BUF+2,X	;SAVE TOP RIGHT TILE
	LDA	T2
	STA	SCRN_BUF+64,X	;SAVE BOTTOM LEFT
	LDA	T3
	STA	SCRN_BUF+66,X	;SAVE BOTTOM RIGHT
	CLC
	TXA
	ADC	#4	;NEXT BLOCK
	TAX
;-----
	DEC	SCRN_WIDTH
	BEQ	@ROW_DONE
	JMP	@LOOP4
@ROW_DONE	CLC
	LDA	SCRN_OFF	;GET START OF THIS ROW
	ADC	#64*2	;ADD 2 ROWS
	STA	SCRN_OFF
	DEC	SCRN_HEIGTH
	BEQ	@MAP_DONE
	JMP	@LOOP3
@MAP_DONE
;-----
;NOW DMA THE DATA OVER TO VRAM
	SET_A8
	LDA	#0
	PHA
	PLB		;RESET BANK FOR TRANSFER
	STZ	MDMAEN	;CLEAR DMA CHANNEL
	LDA	#$01
	STA	WDMAP0	;DMA PARAMETER DATA FOR CHANNEL 0
	LDA	#<WVMDATAL	;WRITE TO HERE
	STA	BADMA0
;
	LDA	#<SCRN_BUF	;GET ADDRESS OF SOURCE
	STA	A1ADMAL0	;LOW
	LDA	#>SCRN_BUF
	STA	A1ADMAH0	;HIGH
	LDA	#^SCRN_BUF	;GET DATA BANK OF SOURCE
	STA	A1ADMAB0	;BANK
;
	LDX	SCRN_PTR
	SET_A16
	LDA	BG1_SC,X	;GET DEST ADDRESS IN VRAM
	STA	VMADDL	;SET VRAM WRITE ADDRESS
;
	LDA	#2048	;# OF BYTES TO SEND
	SET_A8
	STA	DMADATL0	;LOW
	XBA
	STA	DMADATH0	;HIGH
;
	LDA	#1
	STA	MDMAEN	;START DMA
@SKIP
;-----
	SET_AXY16
	LDA	SCRIPT_PTR	;GET POINTER
	CLC
	ADC	#DS_END	;SKIP DATA
	TAY
	PLB
	PLP
	RTS

	MODEND

;------------------
;CLR_SCRN_BUF -- CLEAR THE SCREEN BUFFER

CLR_SCRN_BUF	MODULE

	JSR	DO_CLR_SCRN
	RTL
;=====
DO_CLR_SCRN	PHP
	PHB
;-----
	SET_A8
	SET_XY16
	PHY
	LDA	#^SCRN_BUF
	PHA
	PLB		;SET SCRN_BUF DATA BANK
;-----
	SET_A16
	STZ	SCRN_BUF	;CLEAR FIRST BYTE
	LDX	#<SCRN_BUF	;FROM
	LDY	#<SCRN_BUF+1	;TO
	LDA	#2048-2	;LENGTH
	MVN	SCRN_BUF,SCRN_BUF	;ZERO OUT AREA
;-----
	PLY
	PLB
	PLP
	RTS

	MODEND

;------------------
;CUSTOM_MAP -- INIT A CUSTOM MAP

CUSTOM_MAP	MODULE

	PHP
	PHB
	SET_AXY16
	LDA	#1
	STA	CUSTOM_FLAG
	JMP	DO_CUST_MAP

	MODEND

;------------------
;INIT_MAP -- INITIALIZE A MAP

INIT_MAP	MODULE

	PHP
	PHB
	SET_AXY16
	STZ	CUSTOM_FLAG
;-----
DO_CUST_MAP	STY	SCRIPT_PTR	;SAVE POINTER
	STZ	IN_BUF_PTR
;-----
;GET SCREEN # AND MAKE POINTER
	LDA	IM_SCRN,Y	;GET SCREEN #
	DEC	A
	STA	TEMP_ACC
	ASL	A
	STA	SCRN_PTR
	CLC
	ADC	TEMP_ACC	;SCRN # * 3
	STA	SCRN_PTR3
;-----
;LOAD ALL THE DATA INTO VARIABLES
	LDX	SCRN_PTR
	LDA	IM_MAPX,Y
	STA	MAP1_X,X	;MAP START X
	STA	MAP1_LASTX,X
	STA	MAP1_STARTX,X
	STA	MAP_STARTX
;-----
;IF CUSTOM MAP THEN DOUBLE THE Y VALUE
	LDA	CUSTOM_FLAG
	BEQ	@NOT_CUST1
	LDA	IM_MAPY,Y	;MAP START Y
	ASL	A	;DOUBLE IT
	JMP	@WAS_CUST1
;
@NOT_CUST1	LDA	IM_MAPY,Y
@WAS_CUST1	STA	MAP1_Y,X	;MAP START Y
	STA	MAP1_LASTY,X
	STA	MAP1_STARTY,X
	STA	MAP_STARTY
;
	LDA	IM_MAPW,Y
	STA	MAP1_WIDTH,X	;MAP WIDTH
	STA	MAP_WIDTH
	SEC
	SBC	#16	;MAKE RIGHT EDGE VALUE
	ASL	A
	ASL	A
	ASL	A
	ASL	A	;WIDTH - SCRN * 16 = RIGHT PIXEL EDGE
	STA	RIGHT_EDGE1,X
;-----
;IF CUSTOM MAP THEN DOUBLE THE Y VALUE
	LDA	CUSTOM_FLAG
	BEQ	@NOT_CUST2
	LDA	IM_MAPH,Y
	ASL	A
	JMP	@WAS_CUST2
;
@NOT_CUST2	LDA	IM_MAPH,Y
@WAS_CUST2	STA	MAP1_HEIGTH,X	;MAP HEIGTH
	STA	MAP_HEIGTH

	SEC
	SBC	#14	;MAKE BOTTOM EDGE VALUE
	ASL	A
	ASL	A
	ASL	A
	ASL	A	;WIDTH - SCRN * 16 = BOTTOM PIXEL EDGE
	STA	BOTTOM_EDGE1,X
;-----
;BE SURE THAT CURRENT START X,Y IS NOT OVER AN EDGE
	LDA	MAP1_X,X	;GET START X
	CMP	RIGHT_EDGE1,X	;OVER EDGE ?
	BLT	@RIGHT_OK
	LDA	RIGHT_EDGE1,X
	STA	MAP1_X,X	;MAP START X
	STA	MAP1_LASTX,X
	STA	MAP1_STARTX,X
	STA	MAP_STARTX
;
@RIGHT_OK	LDA	MAP1_Y,X	;GET START Y
	CMP	BOTTOM_EDGE1,X	;OVER EDGE ?
	BLT	@BOTTOM_OK
	LDA	BOTTOM_EDGE1,X
	STA	MAP1_Y,X	;MAP START Y
	STA	MAP1_LASTY,X
	STA	MAP1_STARTY,X
	STA	MAP_STARTY
;-----
@BOTTOM_OK	PHX
	TXA
	LSR	A
	TAX
	SET_A8
	LDA	IM_MAPSCROLL,Y
	STA	MAP1_SC_FLAG,X	;SET SCROLL FLAG
	PLX
	SET_A16

;
	LDA	IM_MAPADD,Y	;GET OFFSET OF MAP
	STA	MAP_IN_ROM	;SAVE OFFSET
	LDA	IM_BLKADD,Y	;GET OFFSET OF BLOCK
	STA	BLK_IN_ROM	;SAVE OFFSET
;
	LDA	IM_FLRADD,Y	;GET FLOOR ADDRESS
	STA	FLR_IN_ROM
	LDA	IM_CONADD,Y	;GET CONTOUR ADDRESS
	STA	CON_IN_ROM
;
	SET_A8
	LDA	IM_MAPPAGE,Y	;GET BANK OF MAP
	STA	MAP_IN_ROM+2
	LDA	IM_BLKPAGE,Y	;GET BANK OF BLOCK
	STA	BLK_IN_ROM+2
;
	LDA	IM_FLRPAGE,Y	;GET BANK OF FLOOR
	STA	FLR_IN_ROM+2
	LDA	IM_CONPAGE,Y	;GET BANK OF CONTOUR
	STA	CON_IN_ROM+2
	SET_A16
;
	LDA	IM_BLKSIZE,Y	;GET SIZE OF BLOCK DATA
	STA	BLK_BYTES	;SAVE FOR MOVE
	LDA	IM_MAPSIZE,Y	;GET MAP SIZE IN BYTES
	STA	MAP_BYTES	;SAVE FOR MOVE
;-----
;DECOMPRESS MAP TO NEXT OPEN RAM AREA
	LDA	MAP_IN_ROM
	STA	DCMP_SRC
	LDA	#0
	SET_A8
	LDA	MAP_IN_ROM+2
	SET_A16
	STA	DCMP_SRC+2
;
	LDA	NEXT_RAM
	STA	DCMP_DEST
	STA	MAP_IN_RAM
	LDA	NEXT_RAM+2
	STA	DCMP_DEST+2
	SET_A8
	STA	MAP_IN_RAM+2
	SET_A16
;
	JSL	DECOMPRESS
;-----
;ALLOCATE RAM FOR MAP
	JSL	ALLOC_RAM	;ALLOCATE RAM
	LDX	SCRN_PTR	;GET SCREEN PTR
	STA	MAP1_HANDLE,X	;POINTER TO MAP RAM BLOCK
	STA	MAP_HANDLE	;SAVE IN TEMP HANDLE
;-----
;IF CUSTOM MAP THEN DECOMPRESS IT AGAIN SO IT'S DOUBLE HEIGTH
	LDA	CUSTOM_FLAG
	BEQ	@NOT_CUST3
	LDA	MAP_IN_ROM
	STA	DCMP_SRC
	LDA	#0
	SET_A8
	LDA	MAP_IN_ROM+2
	SET_A16
	STA	DCMP_SRC+2
;
	LDA	NEXT_RAM
	STA	DCMP_DEST
	LDA	NEXT_RAM+2
	STA	DCMP_DEST+2
;
	JSL	DECOMPRESS
;-----
;ALLOCATE RAM FOR CUSTOM MAP
	JSL	ALLOC_RAM	;ALLOCATE RAM
;-----
;DECOMPRESS BLOCK TO NEXT OPEN RAM AREA
@NOT_CUST3	LDA	BLK_IN_ROM
	STA	DCMP_SRC
	LDA	#0
	SET_A8
	LDA	BLK_IN_ROM+2
	SET_A16
	STA	DCMP_SRC+2
;
	LDA	NEXT_RAM
	STA	DCMP_DEST
	STA	BLK_IN_RAM
	LDA	NEXT_RAM+2
	STA	DCMP_DEST+2
	SET_A8
	STA	BLK_IN_RAM+2
	SET_A16

	JSL	DECOMPRESS
;-----
;ALLOCATE RAM FOR BLOCK DATA
	JSL	ALLOC_RAM	;ALLOCATE RAM
	LDX	SCRN_PTR	;GET SCREEN PTR
	STA	BLK1_HANDLE,X	;POINTER TO MAP RAM BLOCK
	STA	BLK_HANDLE	;SAVE IN TEMP HANDLE
;-----
;DECOMPRESS FLOOR TO NEXT OPEN RAM AREA
	LDA	FLR_IN_ROM
	STA	DCMP_SRC
	LDA	#0
	SET_A8
	LDA	FLR_IN_ROM+2
	SET_A16
	STA	DCMP_SRC+2
;
	LDA	NEXT_RAM
	STA	DCMP_DEST
	STA	FLR_IN_RAM
	LDA	NEXT_RAM+2
	STA	DCMP_DEST+2
	SET_A8
	STA	FLR_IN_RAM+2
	SET_A16

	JSL	DECOMPRESS
;-----
;ALLOCATE RAM FOR FLOOR
	JSL	ALLOC_RAM	;ALLOCATE RAM
	LDX	SCRN_PTR	;GET SCREEN PTR
	STA	FLR1_HANDLE,X	;POINTER TO MAP RAM BLOCK
	STA	FLR_HANDLE	;SAVE IN TEMP HANDLE
;-----
;COPY MAP TO RAM
;	LDX	MAP_HANDLE
;	LDA	RAM_BLOCK0,X	;OFFSET OF AVAILABLE RAM
;	STA	MAP_IN_RAM
;	LDA	RAM_BLOCK0+2,X
;	SET_A8
;	STA	MAP_IN_RAM+2	;BANK OF RAM
;	SET_A16
;	JSR	MAP_2_RAM	;COPY MAP INTO WORK RAM
;-----
;COPY BLOCK TO RAM
;	LDX	BLK_HANDLE
;	LDA	RAM_BLOCK0,X	;OFFSET OF AVAILABLE RAM
;	STA	BLK_IN_RAM
;	LDA	RAM_BLOCK0+2,X
;	SET_A8
;	STA	BLK_IN_RAM+2	;BANK OF RAM
;	SET_A16
;	JSR	BLK_2_RAM	;COPY BLOCK DATA TO WORK RAM
;-----
	JSL	CLR_SCRN_BUF	;CLEAR OUT THE SCRN_BUF
;-----
;SAVE LOCATION OF DATA AREAS
	LDX	SCRN_PTR3
	LDA	MAP_IN_RAM
	STA	MAP1_IN_RAM,X	;SET ADDRESS OF MAP
	LDA	BLK_IN_RAM
	STA	BLK1_IN_RAM,X	;SET ADDRESS OF BLOCK
	LDA	FLR_IN_RAM
	STA	FLR1_IN_RAM,X	;SET ADDRESS OF FLOOR
	SET_A8
	LDA	MAP_IN_RAM+2	;GET PAGE #
	STA	MAP1_IN_RAM+2,X
	LDA	BLK_IN_RAM+2	;GET PAGE #
	STA	BLK1_IN_RAM+2,X
	LDA	FLR_IN_RAM+2	;GET PAGE #
	STA	FLR1_IN_RAM+2
;-----
	SET_A16
	JSR	DRAW_QUADS
;-----
IM_DONE	SET_AXY16
	LDA	SCRIPT_PTR	;GET POINTER
	CLC
	ADC	#IM_END	;SKIP DATA
	TAY
	PLB
	PLP
	RTS
;-----
;DRAW SCREEN SIZE = 1
DRAW_QUADS	SET_A16
	LDA	SCRN_PTR
	LSR	A	;MAKE BYTE PTR
	TAX
	SET_A8
	LDA	BG1_SIZE,X	;GET SCREEN SIZE
	CMP	#0	;1 SCREEN ?
	BNE	@SIZE1
	JSR 	QUAD1	;DRAW QUAD 1
	RTS
;-----
@SIZE1	CMP	#1	;2 SCREENS WIDE ?
	BNE	@SIZE2
	JSR	QUAD1	;LEFT SIDE
	JSR	QUAD2	;RIGHT SIDE
	RTS
;-----
@SIZE2	CMP	#2	;2 SCREENS HIGH
	BNE	@SIZE3
	JSR	QUAD1
	JSR	QUAD2V
	RTS
;-----
@SIZE3 	JSR	QUAD1
	JSR	QUAD2
	JSR	QUAD3
	JSR	QUAD4
	RTS
;=====
;DRAW QUAD 1
QUAD1	SET_AXY16

	LDA	MAP_STARTX	;GET MAP X TO START AT
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;X / 16 = BLOCK #
	AND	#$FFF0	;ROUND TO SCREEN EDGE
	STA	TEMP_X
;
	LDA	MAP_STARTX	;GET MAP X TO START AT
	XBA
	AND	#1	;SEE WHICH X SCREEN TO DRAW
	ASL	A
	ASL	A
	ASL	A
	ASL	A	; x 16 = 0 OR 16
	CLC
	ADC	TEMP_X
	TAY		;SET X
;
	LDA	MAP_STARTY	;GET START Y
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;X / 16 = BLOCK #
	AND	#$FFF0	;ROUND TO SCREEN TOP
	STA	TEMP_X
;
	LDA	MAP_STARTY	;GET START Y
	XBA
	AND	#1	;SEE WHICH Y SCREEN TO DRAW
	ASL	A
	ASL	A
	ASL	A
	ASL	A	; x 16 = 0 OR 16
	CLC
	ADC	TEMP_X	;SET Y
	LDX	MAP_WIDTH	;Y x WIDTH

;	LDA	MAP_STARTY	;GET START Y
;	LDX	MAP_WIDTH	;Y x WIDTH
;	LDY	MAP_STARTX	;GET START X

	JSL	CALC_OFF	;CALC THE MAP_OFF
	JSR	DRAW_MAP	;DRAW THE MAP TO SCRN_BUF
	LDY	#0
	JMP	DMA_SCRN	;DMA THE SCRN_BUF TO VRAM

;=====
;DRAW QUAD 2
QUAD2	SET_AXY16

	LDA	MAP_STARTX	;GET MAP X TO START AT
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;X / 16 = BLOCK #
	AND	#$FFF0	;ROUND TO SCREEN EDGE
	STA	TEMP_X
;
	LDA	MAP_STARTX	;GET MAP X TO START AT
	CLC
	ADC	#$100	;1 SCREEN TO THE RIGHT
	XBA
	AND	#1	;SEE WHICH X SCREEN TO DRAW
	ASL	A
	ASL	A
	ASL	A
	ASL	A	; x 16 = 0 OR 16
	CLC
	ADC	TEMP_X
	TAY		;SET X
;
	LDA	MAP_STARTY	;GET START Y
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;X / 16 = BLOCK #
	AND	#$FFF0	;ROUND TO SCREEN TOP
	STA	TEMP_X
;
	LDA	MAP_STARTY	;GET START Y
	XBA
	AND	#1	;SEE WHICH Y SCREEN TO DRAW
	ASL	A
	ASL	A
	ASL	A
	ASL	A	; x 16 = 0 OR 16
	CLC
	ADC	TEMP_X	;SET Y
	LDX	MAP_WIDTH	;Y x WIDTH



;	LDA	MAP_STARTX	;GET START X
;	CLC
;	ADC	#32	;1 SCREEN TO THE RIGHT
;	TAY
;	LDA	MAP_STARTY	;GET START Y
;	LDX	MAP_WIDTH	;Y x WIDTH

	JSL	CALC_OFF	;CALC THE MAP_OFF
	JSR	DRAW_MAP	;DRAW THE MAP TO SCRN_BUF
	LDY	#$400
	JMP	DMA_SCRN	;DMA THE SCRN_BUF TO VRAM
;=====
;DRAW QUAD 2 VERTICAL
QUAD2V	SET_AXY16




	LDA	MAP_STARTX	;GET MAP X TO START AT
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;X / 16 = BLOCK #
	AND	#$FFF0	;ROUND TO SCREEN EDGE
	STA	TEMP_X
;
	LDA	MAP_STARTX	;GET MAP X TO START AT
	XBA
	AND	#1	;SEE WHICH X SCREEN TO DRAW
	ASL	A
	ASL	A
	ASL	A
	ASL	A	; x 16 = 0 OR 16
	CLC
	ADC	TEMP_X
	TAY		;SET X
;
	LDA	MAP_STARTY	;GET START Y
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;X / 16 = BLOCK #
	AND	#$FFF0	;ROUND TO SCREEN TOP
	STA	TEMP_X
;
	LDA	MAP_STARTY	;GET START Y
	CLC
	ADC	#$100	;1 PAGE DOWN
	XBA
	AND	#1	;SEE WHICH Y SCREEN TO DRAW
	ASL	A
	ASL	A
	ASL	A
	ASL	A	; x 16 = 0 OR 16
	CLC
	ADC	TEMP_X	;SET Y
	LDX	MAP_WIDTH	;Y x WIDTH



;	LDA	MAP_STARTY	;GET START Y
;	CLC
;	ADC	#16*2	;NEXT SCREEN DOWN
;	LDX	MAP_WIDTH	;Y x WIDTH
;	LDY	MAP_STARTX	;GET START X


	JSL	CALC_OFF	;CALC THE MAP_OFF
	JSR	DRAW_MAP	;DRAW THE MAP TO SCRN_BUF
	LDY	#$400
	JMP	DMA_SCRN	;DMA THE SCRN_BUF TO VRAM
;=====
;DRAW QUAD 3
QUAD3	SET_AXY16


	LDA	MAP_STARTX	;GET MAP X TO START AT
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;X / 16 = BLOCK #
	AND	#$FFF0	;ROUND TO SCREEN EDGE
	STA	TEMP_X
;
	LDA	MAP_STARTX	;GET MAP X TO START AT
	XBA
	AND	#1	;SEE WHICH X SCREEN TO DRAW
	ASL	A
	ASL	A
	ASL	A
	ASL	A	; x 16 = 0 OR 16
	CLC
	ADC	TEMP_X
	TAY		;SET X
;
	LDA	MAP_STARTY	;GET START Y
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;X / 16 = BLOCK #
	AND	#$FFF0	;ROUND TO SCREEN TOP
	STA	TEMP_X
;
	LDA	MAP_STARTY	;GET START Y
	CLC
	ADC	#$100	;1 PAGE DOWN
	XBA
	AND	#1	;SEE WHICH Y SCREEN TO DRAW
	ASL	A
	ASL	A
	ASL	A
	ASL	A	; x 16 = 0 OR 16
	CLC
	ADC	TEMP_X	;SET Y
	LDX	MAP_WIDTH	;Y x WIDTH


;	LDA	MAP_STARTY	;GET START Y
;	CLC
;	ADC	#16	;NEXT SCREEN DOWN
;	LDX	MAP_WIDTH	;Y x WIDTH
;	LDY	MAP_STARTX	;GET START X

	JSL	CALC_OFF	;CALC THE MAP_OFF
	JSR	DRAW_MAP	;DRAW THE MAP TO SCRN_BUF
	LDY	#$400*2
	JMP	DMA_SCRN	;DMA THE SCRN_BUF TO VRAM
;=====
;DRAW QUAD 4
QUAD4	SET_AXY16


	LDA	MAP_STARTX	;GET MAP X TO START AT
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;X / 16 = BLOCK #
	AND	#$FFF0	;ROUND TO SCREEN EDGE
	STA	TEMP_X
;
	LDA	MAP_STARTX	;GET MAP X TO START AT
	CLC
	ADC	#$100	;1 SCREEN TO THE RIGHT
	XBA
	AND	#1	;SEE WHICH X SCREEN TO DRAW
	ASL	A
	ASL	A
	ASL	A
	ASL	A	; x 16 = 0 OR 16
	CLC
	ADC	TEMP_X
	TAY		;SET X
;
	LDA	MAP_STARTY	;GET START Y
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;X / 16 = BLOCK #
	AND	#$FFF0	;ROUND TO SCREEN TOP
	STA	TEMP_X
;
	LDA	MAP_STARTY	;GET START Y
	CLC
	ADC	#$100	;1 PAGE DOWN
	XBA
	AND	#1	;SEE WHICH Y SCREEN TO DRAW
	ASL	A
	ASL	A
	ASL	A
	ASL	A	; x 16 = 0 OR 16
	CLC
	ADC	TEMP_X	;SET Y
	LDX	MAP_WIDTH	;Y x WIDTH



;	LDA	MAP_STARTX	;GET START X
;	CLC	
;	ADC	#32	;ONE SCREEN OVER
;	TAY
;	LDA	MAP_STARTY	;GET START Y
;	CLC
;	ADC	#16	;ONE SCREEN DOWN
;	LDX	MAP_WIDTH	;Y x WIDTH

	JSL	CALC_OFF	;CALC THE MAP_OFF
	JSR	DRAW_MAP	;DRAW THE MAP TO SCRN_BUF
	LDY	#$400*3
	JMP	DMA_SCRN	;DMA THE SCRN_BUF TO VRAM

	MODEND

;------------------
;ADD_AMAP -- INITIALIZE A MAP

ADD_AMAP	MODULE

	PHP
	PHB
	SET_AXY16
	STY	SCRIPT_PTR	;SAVE POINTER
;-----
;GET SCREEN # AND MAKE POINTER
	LDA	IM_SCRN,Y	;GET SCREEN #
	DEC	A
	STA	TEMP_ACC
	ASL	A
	STA	SCRN_PTR
	CLC
	ADC	TEMP_ACC	;SCRN # * 3
	STA	SCRN_PTR3
;-----
;LOAD ALL THE DATA INTO VARIABLES
	LDX	SCRN_PTR
	LDA	IM_MAPX,Y
	STA	MAP1_X,X	;MAP START X
	STA	MAP1_LASTX,X
	STA	MAP1_STARTX,X
	STA	MAP_STARTX
	LDA	IM_MAPY,Y
	STA	MAP1_Y,X	;MAP START Y
	STA	MAP1_LASTY,X
	STA	MAP1_STARTY,X
	STA	MAP_STARTY
;
	LDA	IM_MAPW,Y
	STA	MAP1_WIDTH,X	;MAP WIDTH
	STA	MAP_WIDTH
	SEC
	SBC	#16	;MAKE RIGHT EDGE VALUE
	ASL	A
	ASL	A
	ASL	A
	ASL	A	;WIDTH - SCRN * 16 = RIGHT PIXEL EDGE
	STA	RIGHT_EDGE1,X
	LDA	IM_MAPH,Y
	STA	MAP1_HEIGTH,X	;MAP HEIGTH
	STA	MAP_HEIGTH

	SEC
	SBC	#14	;MAKE BOTTOM EDGE VALUE
	ASL	A
	ASL	A
	ASL	A
	ASL	A	;WIDTH - SCRN * 16 = BOTTOM PIXEL EDGE
	STA	BOTTOM_EDGE1,X
;
	PHX
	TXA
	LSR	A
	TAX
	SET_A8
	LDA	IM_MAPSCROLL,Y
	STA	MAP1_SC_FLAG,X	;SET SCROLL FLAG
	PLX
	SET_A16

;
	LDA	IM_MAPADD,Y	;GET OFFSET OF MAP
	STA	MAP_IN_ROM	;SAVE OFFSET
;
	SET_A8
	LDA	IM_MAPPAGE,Y	;GET BANK OF MAP
	STA	MAP_IN_ROM+2
;
	SET_A16
	LDA	IM_MAPSIZE,Y	;GET MAP SIZE IN BYTES
	STA	MAP_BYTES	;SAVE FOR MOVE
;-----
;DECOMPRESS MAP TO NEXT OPEN RAM AREA
	LDA	MAP_IN_ROM
	STA	DCMP_SRC
	LDA	#0
	SET_A8
	LDA	MAP_IN_ROM+2
	SET_A16
	STA	DCMP_SRC+2
;
	LDA	NEXT_RAM
	STA	DCMP_DEST
	STA	MAP_IN_RAM
	LDA	NEXT_RAM+2
	STA	DCMP_DEST+2
	SET_A8
	STA	MAP_IN_RAM+2
	SET_A16
;
	JSL	DECOMPRESS
;-----
;ALLOCATE RAM FOR MAP
	JSL	ALLOC_RAM	;ALLOCATE RAM
	LDX	SCRN_PTR	;GET SCREEN PTR
	STA	MAP1_HANDLE,X	;POINTER TO MAP RAM BLOCK
	STA	MAP_HANDLE	;SAVE IN TEMP HANDLE
;-----
	JSL	CLR_SCRN_BUF	;CLEAR OUT THE SCRN_BUF
;-----
;SAVE LOCATION OF DATA AREAS
	LDX	SCRN_PTR3
	LDA	MAP_IN_RAM
	STA	MAP1_IN_RAM,X	;SET ADDRESS OF MAP
;-----
;USE BACKGROUND #1 DATA FOR REST OF THIS
	LDA	BLK1_IN_RAM
	STA	BLK1_IN_RAM,X	;SET ADDRESS OF BLOCK
	LDA	FLR1_IN_RAM
	STA	FLR1_IN_RAM,X	;SET ADDRESS OF FLOOR
	SET_A8
	LDA	MAP_IN_RAM+2	;GET PAGE #
	STA	MAP1_IN_RAM+2,X
	LDA	BLK1_IN_RAM+2	;GET PAGE #
	STA	BLK1_IN_RAM+2,X
	LDA	FLR1_IN_RAM+2	;GET PAGE #
	STA	FLR1_IN_RAM+2,X
;-----
@SKIP	SET_A16
	JSR	DRAW_QUADS
;-----
	SET_AXY16
	LDA	SCRIPT_PTR	;GET POINTER
	CLC
	ADC	#AM_END	;SKIP DATA
	TAY
	PLB
	PLP
	RTS


	MODEND

;------------------
;MAP_2_RAM -- COPY MAP DATA TO WORK RAM

MAP_2_RAM	MODULE

	PHP
;
	SET_A8
	STZ	MDMAEN	;CLEAR DMA CHANNEL
	LDA	#$00
	STA	WDMAP0	;DMA PARAMETER DATA FOR CHANNEL 0
	LDA	#<WMDATA	;WRITE TO WORK RAM
	STA	BADMA0
;
	LDA	MAP_IN_ROM
	STA	A1ADMAL0	;LOW
	LDA	MAP_IN_ROM+1
	STA	A1ADMAH0	;HIGH
;
	LDA	MAP_IN_ROM+2
	STA	A1ADMAB0	;BANK
;
	LDA	MAP_IN_RAM
	STA	WMADDL	;DEST LOW
	LDA	MAP_IN_RAM+1
	STA	WMADDM	;DEST HIGH
	LDA	MAP_IN_RAM+2
	STA	WMADDH	;DEST BANK
;
	LDA	MAP_BYTES
	STA	DMADATL0	;LOW
	LDA	MAP_BYTES+1
	STA	DMADATH0	;HIGH
;
	LDA	#1
	STA	MDMAEN	;START DMA
;	
	PLP
	RTS

	MODEND

;------------------
;BLK_2_RAM -- COPY BLOCK DATA TO WORK RAM

BLK_2_RAM	MODULE

	PHP
;
	SET_A8
	STZ	MDMAEN	;CLEAR DMA CHANNEL
	LDA	#$00
	STA	WDMAP0	;DMA PARAMETER DATA FOR CHANNEL 0
	LDA	#<WMDATA	;WRITE TO WORK RAM
	STA	BADMA0
;
	LDA	BLK_IN_ROM
	STA	A1ADMAL0	;LOW
	LDA	BLK_IN_ROM+1
	STA	A1ADMAH0	;HIGH
;
	LDA	BLK_IN_ROM+2
	STA	A1ADMAB0	;BANK
;
	LDA	BLK_IN_RAM
	STA	WMADDL	;DEST LOW
	LDA	BLK_IN_RAM+1
	STA	WMADDM	;DEST HIGH
	LDA	BLK_IN_RAM+2
	STA	WMADDH	;DEST BANK
;
	LDA	BLK_BYTES
	STA	DMADATL0	;LOW
	LDA	BLK_BYTES+1
	STA	DMADATH0	;HIGH
;
	LDA	#1
	STA	MDMAEN	;START DMA
;	
	PLP
	RTS

	MODEND

;------------------
;CALC_OFF -- CALCULATE THE MAP_OFF FOR THIS X,Y POSITION

CALC_OFF	MODULE

	SET_AXY8
	STA	WRMPYA	;SET MULTIPLICAND
	STX	WRMPYB	;SET MULTIPLIER
	NOP
	NOP
	NOP
	NOP
	NOP		;WAIT 8 CYCLES
	LDA	RDMPYH	;GET HIGH
	XBA
	LDA	RDMPYL	;GET LOW
	SET_AXY16
	ASL	A	;TEST
	STA	MAP_OFF	;SAVE IT
	TYA		;GET START X
	ASL	A
	CLC
	ADC	MAP_OFF	;ADD MAP X
	STA	MAP_OFF	;SAVE IT
	RTL

	MODEND


;------------------;------------------
;DRAW_MAP -- DRAW A 32 x 32 AREA FROM THE MAP INTO THE SCRN_BUF

DRAW_MAP	MODULE

	PHP
;-----
	SET_A8
	LDA	#^SCRN_BUF
	PHA
	PLB    		;SET SCRN_BUF PAGE
	SET_A16
;
	LDA    	#16
	STA	SCRN_HEIGTH	;SET COUNTER
	LDX	#0	;START NEW ROW
;
@LOOP3	LDA	#16	;WIDTH OF ONE SCREEN
	STA	SCRN_WIDTH	;SET COUNTER
	LDY	MAP_OFF	;FROM MAP
;
@LOOP4	LDA	[MAP_IN_RAM],Y	;GET A MAP REFERENCE
	INY
	INY
	PHY
	TAY
	AND	#$3C00
	STA	MAP_PC	;SAVE PRIORITY AND COLOR
	TYA
	AND	#$C000
	STA	MAP_FB	;SAVE FLIP BITS
	TYA
	AND	#$03FF	;JUST INDEX DATA
	ASL
	ASL
	ASL
	TAY		;POINT INTO BLOCK DATA
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY
	STA	T0	;SAVE TILE 0
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY
	STA	T1	;SAVE TILE 1
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY
	STA	T2	;SAVE TILE 2
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	STA	T3	;SAVE TILE 3
;-----
;TEST FLIP BITS AND ADJUST
	LDA	MAP_FB	;GET FLIP BITS
	BIT	#$4000	;X FLIP ?
	BEQ	@NO_X_FLIP
	LDA	T0
	LDY	T1
	STA	T1
	STY	T0	;FLIP T0,T1
	LDA	T2
	LDY	T3
	STA	T3
	STY	T2	;FLIP T2,T3
;
@NO_X_FLIP	LDA	MAP_FB	;GET FLIP BITS
	BIT	#$8000	;Y FLIP ?
	BEQ	@NO_Y_FLIP
	LDA	T0
	LDY	T2
	STA	T2
	STY	T0	;FLIP T0,T2
	LDA	T1
	LDY	T3
	STA	T3
	STY	T1	;FLIP T1,T3
@NO_Y_FLIP	PLY
;-----
;NOW STORE IT IN THE CORRECT LOCATION IN THE SCRN_BUF
	LDA	T0
	STA	SCRN_BUF,X	;SAVE TOP LEFT TILE
	LDA	T1
	STA	SCRN_BUF+2,X	;SAVE TOP RIGHT TILE
	LDA	T2
	STA	SCRN_BUF+64,X	;SAVE BOTTOM LEFT
	LDA	T3
	STA	SCRN_BUF+66,X	;SAVE BOTTOM RIGHT
	CLC
	TXA
	ADC	#4	;NEXT BLOCK
	TAX
;-----
	DEC	SCRN_WIDTH
	BEQ	@ROW_DONE
	JMP	@LOOP4
;
@ROW_DONE	DEC	SCRN_HEIGTH
	BEQ	@MAP_DONE
	CLC
	LDA	MAP_OFF	;GET START OF THIS ROW
	ADC	MAP_WIDTH
	ADC	MAP_WIDTH	;NEXT MAP ROW
	STA	MAP_OFF
	TXA
	CLC
	ADC	#64	;SKIP 2ND ROWS
	TAX
	JMP	@LOOP3
@MAP_DONE
	PLP
	RTS

	MODEND

;------------------
;DMA_SCRN -- DMA THE SCRN_BUF OVER TO THE VRAM

DMA_SCRN	MODULE

	PHP
	SET_A8
	LDA	#0
	PHA
	PLB		;RESET BANK FOR TRANSFER
	STZ	MDMAEN	;CLEAR DMA CHANNEL
	LDA	#$01
	STA	WDMAP0	;DMA PARAMETER DATA FOR CHANNEL 0
	LDA	#<WVMDATAL	;WRITE TO HERE
	STA	BADMA0
;
	LDA	#<SCRN_BUF	;GET ADDRESS OF SOURCE
	STA	A1ADMAL0	;LOW
	LDA	#>SCRN_BUF
	STA	A1ADMAH0	;HIGH
	LDA	#^SCRN_BUF	;GET DATA BANK OF SOURCE
	STA	A1ADMAB0	;BANK
;
	SET_A16
	LDX	SCRN_PTR
	TYA
	CLC
	ADC	BG1_SC,X	;MAKE DEST ADDRESS IN VRAM
	STA	VMADDL	;SET VRAM WRITE ADDRESS
	LDA	#2048	;# OF BYTES TO SEND
	SET_A8
	STA	DMADATL0	;LOW
	XBA
	STA	DMADATH0	;HIGH
;
	LDA	#1
	STA	MDMAEN	;START DMA
	PLP
	RTS

	MODEND

;------------------
;SET_PLAYER -- SET THE PLAYER'S STARTING X,Y AND SET SCROLL VALUES

SET_PLAYER	MODULE

	PHP
	SET_AXY16
	STY	SCRIPT_PTR	;SAVE POINTER
;-----
	LDA	P_X,Y	;GET X
	STA	PLAYER_X
	SEC
	SBC	#128
	STA	MAP1_X
	STA	MAP1_LASTX
	STA	MAP2_X
	STA	MAP2_LASTX
	STA	MAP3_X
	STA	MAP3_LASTX
	SET_A8
	STA	BG1HOFS	;LOW BYTE
	XBA
	STA	BG1HOFS	;HIGH BYTE
	XBA
	STA	BG2HOFS	;LOW BYTE
	XBA
	STA	BG2HOFS	;HIGH BYTE
	XBA
	STA	BG3HOFS	;LOW BYTE
	XBA
	STA	BG3HOFS	;HIGH BYTE
	SET_A16
;
	LDA	P_Y,Y	;GET Y
	STA	PLAYER_Y
	SEC
	SBC	#128
	STA	MAP1_Y
	STA	MAP1_LASTY
	STA	MAP2_Y
	STA	MAP2_LASTY
	STA	MAP3_Y
	STA	MAP3_LASTY
	SET_A8
	STA	BG1VOFS	;LOW BYTE
	XBA
	STA	BG1VOFS	;HIGH BYTE
	XBA
	STA	BG2VOFS	;LOW BYTE
	XBA
	STA	BG2VOFS	;HIGH BYTE
	XBA
	STA	BG3VOFS	;LOW BYTE
	XBA
	STA	BG3VOFS	;HIGH BYTE
	SET_A16
;-----
	CLC
	LDA	SCRIPT_PTR
	ADC	#PXY_END
	STA	SCRIPT_PTR
	TAY
	PLP
	RTS

	MODEND

;------------------
;DO_CLR_BKGD -- CLEAR A BACKGROUND IN VRAM

;-----

ZERO_WORD	DW	0	;USED FOR CLEARING VRAM

;-----

DO_CLR_BKGD	MODULE

	PHP
;
	SET_A16	
	LDA	#0	;CLEAR HIGH BYTE
	SET_A8
	LDA	$0,Y	;GET SCREEN # TO CLEAR
	INY
	SET_A16
	DEC	A	;MAKE 0 - 3 FROM 1 - 4
	ASL	A	;WORD PTR
	TAX
;
	SET_A8
	STZ	MDMAEN	;CLEAR DMA CHANNEL
	LDA	#$09	;FIXED SOURCE TO VRAM
	STA	WDMAP0	;DMA PARAMETER DATA FOR CHANNEL 0
	LDA	#<WVMDATAL	;WRITE TO HERE
	STA	BADMA0
;
	LDA	#<ZERO_WORD	;GET ADDRESS OF SOURCE
	STA	A1ADMAL0	;LOW
	LDA	#>ZERO_WORD
	STA	A1ADMAH0	;HIGH
	LDA	#^ZERO_WORD	;GET DATA BANK OF SOURCE
	STA	A1ADMAB0	;BANK
;
	SET_A16
	LDA	BG1_SC,X	;MAKE DEST ADDRESS IN VRAM
	STA	VMADDL	;SET VRAM WRITE ADDRESS
	LDA	#(32*32)*2	;# OF BYTES TO SEND
	SET_A8
	STA	DMADATL0	;LOW
	XBA
	STA	DMADATH0	;HIGH
;
	LDA	#1
	STA	MDMAEN	;START DMA
;
	PLP
	RTS


	MODEND

;------------------
;DO_CLR_VRAM -- CLEAR ALL OF VRAM

DO_CLR_VRAM	MODULE

	PHP
;
	SET_A8
	STZ	MDMAEN	;CLEAR DMA CHANNEL
	LDA	#$09	;FIXED SOURCE TO VRAM
	STA	WDMAP0	;DMA PARAMETER DATA FOR CHANNEL 0
	LDA	#<WVMDATAL	;WRITE TO HERE
	STA	BADMA0
;
	LDA	#<ZERO_WORD	;GET ADDRESS OF SOURCE
	STA	A1ADMAL0	;LOW
	LDA	#>ZERO_WORD
	STA	A1ADMAH0	;HIGH
	LDA	#^ZERO_WORD	;GET DATA BANK OF SOURCE
	STA	A1ADMAB0	;BANK
;
	SET_A16
	LDA	0	;MAKE DEST ADDRESS IN VRAM
	STA	VMADDL	;SET VRAM WRITE ADDRESS
	LDA	#-1	;# OF BYTES TO SEND
	SET_A8
	STA	DMADATL0	;LOW
	XBA
	STA	DMADATH0	;HIGH
;
	LDA	#1
	STA	MDMAEN	;START DMA
;
	PLP
	RTS


	MODEND


;------------------
;TEST_DCMP -- TEST THE DECOMPRESSION ROUTINE

TEST_BUF	HEX	98CCA6600C668010
	HEX	A6A014E6C000

	HEX	98CCA6600DC000

TEST_DCMP	MODULE

	PHP
	SET_AXY16
;-----
	LDA	#<TEST_BUF
	STA	DCMP_SRC
	LDA	#^TEST_BUF
	STA	DCMP_SRC+2
;-----
	LDA	MAP_IN_RAM
	STA	DCMP_DEST
	LDA	MAP_IN_RAM+2
	STA	DCMP_DEST+2
;-----
	LDX	#<TEST_BUF
	JSL	DECOMPRESS
;-----
	PLP
	RTL

	MODEND

;------------------
;DECOMPRESS -- DECOMPRESS DATA FROM DB:X TO [DCMP_DEST]

BIT_MASK1	HEX	8040201008040201
BIT_MASK2	HEX	F0783C1E0F070301
BIT_MASK3	HEX	000000000080C0E0

BIT_MASK4	HEX	FF7F3F1F0F070301
BIT_MASK5	HEX	0080C0E0F0F8FCFE

G4_JMPS	DW	G4_B0	
	DW	G4_B1
	DW	G4_B2
	DW	G4_B3
	DW	G4_B4
	DW	G4_B5
	DW	G4_B6
	DW	G4_B7

G8_JMPS	DW	G8_B0	
	DW	G8_B1
	DW	G8_B2
	DW	G8_B3
	DW	G8_B4
	DW	G8_B5
	DW	G8_B6
	DW	G8_B7

G10_JMPS	DW	G10_B0	
	DW	G10_B1
	DW	G10_B2
	DW	G10_B3
	DW	G10_B4
	DW	G10_B5
	DW	G10_B6
	DW	G10_B7

DECOMPRESS	MODULE

	PHP
	PHB
	SET_A8
	LDA	#^BIT_MASK1
	PHA
	PLB
	SET_XY16
;-----
	LDY	#0
	STY	SRC_BIT_PTR
	STY	SRC_PTR
	STY	DEST_PTR
;-----
@DCMP_LP1	JSR	@GET_1BIT	;IS IT AN INDEX OR DATA ?
	CMP	#0
	BEQ	@IS_INDEX
	JSR	@GET_8BITS	;GET DATA
	PHY
	LDY	DEST_PTR
	STA	[DCMP_DEST],Y	;SAVE BYTE OF DATA
	INY
	STY	DEST_PTR
	PLY
	JMP	@DCMP_LP1
;-----
@IS_INDEX	JSR	@GET_10BITS	;GET INDEX
;
	LONGA	ON
;
	CMP	#0
	BEQ	@ALL_DONE
	STA	TEMP_X	;SAVE INDEX
	LDA	DEST_PTR
	SEC
	SBC	TEMP_X	;GO BACK THE INDEX DISTANCE
	STA	TEMP_X	;SOURCE ADDRESS
	SET_A8
	JSR	@GET_4BITS
	PHY
	INC	A	;# + 1 = LENGTH - 1
	SET_A16
	PHA
	LDA	TEMP_X
	CLC
	ADC	DCMP_DEST
	TAX
	LDA	DEST_PTR
	CLC
	ADC	DCMP_DEST
	TAY	
	PLA
	SET_A8
	PHB
	MVN	RAM_START,RAM_START	;MOVE BLOCK OF MEMORY
	PLB
	SET_A16
	TYA
	SEC
	SBC	DCMP_DEST
	STA	DEST_PTR	;SAVE NEW DESTINATION
	SET_A8
	PLY
	JMP	@DCMP_LP1
;-----
	LONGA	ON
;
@ALL_DONE	LDA	DEST_PTR
	PLB
	PLP
	RTL
;
	LONGA	OFF
;=====
@GET_1BIT	LDX	SRC_BIT_PTR
	LDA	[DCMP_SRC],Y	;GET BYTE OF CURRENT DATA
	AND	BIT_MASK1,X	;MASK ONLY 1 BIT
	INX
@CK_BITS	CPX	#8
	BEQ	@LAST_BIT
	STX	SRC_BIT_PTR
	RTS
@LAST_BIT	INY		;NEXT BYTE OF SOURCE
	LDX	#0
	STX	SRC_BIT_PTR
	RTS
;=====
@GET_4BITS	LDX	SRC_BIT_PTR
	CPX	#5	;ALL 4 IN THIS BYTE
	BGE	@G4_10
	LDA	[DCMP_SRC],Y 	;GET DATA
	AND	BIT_MASK2,X	;MASK OFF THE DATA
;
	PHY
	PHA
	SET_A16
	TXA
	ASL	A
	TAX
	SET_A8
	PLA
	JMP	(G4_JMPS,X)
;
G4_B0	LSR	A
	LSR	A	
	LSR	A	
	LSR	A
	LDX	#4
	STX	SRC_BIT_PTR
	PLY
	RTS	
;
G4_B1	LSR	A
	LSR	A	
	LSR	A
	LDX	#5
	STX	SRC_BIT_PTR
	PLY
	RTS	
;
G4_B2	LSR	A
	LSR	A
	LDX	#6
	STX	SRC_BIT_PTR
	PLY
	RTS	
;
G4_B3	LSR	A
	LDX	#7
	STX	SRC_BIT_PTR
	PLY
	RTS	
;
G4_B4	PLY
	INY
	LDX	#0
	STX	SRC_BIT_PTR
	RTS
;-----
;GET ALL THE BITS WE CAN THEN GET REST FROM NEXT BYTE
@G4_10	LDA	[DCMP_SRC],Y	;GET 1ST BYTE
	AND	BIT_MASK2,X	;MASK OFF THE DATA
	XBA
	INY
	LDA	[DCMP_SRC],Y	;GET 2ND BYTE
	AND	BIT_MASK3,X	;MASK OFF THE DATA
	SET_A16
	CPX	#5
	BEQ	G4_B5
	CPX	#6
	BEQ	G4_B6
;
G4_B7	ASL	A
	ASL	A
	ASL	A
	XBA
	LDX	#3
	STX	SRC_BIT_PTR
	SET_A8
	RTS
;
	LONGA	ON
;
G4_B5	ASL	A
	XBA
	SET_A8
	LDX	#1
	STX	SRC_BIT_PTR
	RTS
;
	LONGA	ON
;
G4_B6	ASL	A
	ASL	A
	XBA
	SET_A8
	LDX	#2
	STX	SRC_BIT_PTR
	RTS

	
;=====
@GET_8BITS	LDX	SRC_BIT_PTR
	LDA	[DCMP_SRC],Y	;GET 1ST BYTE
	AND	BIT_MASK4,X	;MASK OFF THE DATA
	XBA
	INY
	LDA	[DCMP_SRC],Y	;GET 2ND BYTE
	AND	BIT_MASK5,X	;MASK OFF THE DATA
	SET_A16
	PHA
	TXA
	ASL	A
	TAX
	PLA
	JMP	(G8_JMPS,X)
;-----
G8_B0	XBA
	SET_A8
	RTS
;-----
G8_B1	ASL	A
	XBA
	SET_A8
	RTS
;-----
G8_B2	ASL	A
	ASL	A
	XBA
	SET_A8
	RTS
;-----
G8_B3	ASL	A
	ASL	A
	ASL	A
	XBA
	SET_A8
	RTS
;-----
G8_B4	LSR	A
	LSR	A
	LSR	A
	LSR	A
	SET_A8
	RTS
;-----
G8_B5	LSR	A
	LSR	A
	LSR	A
	SET_A8
	RTS
;-----
G8_B6	LSR	A
	LSR	A
	SET_A8
	RTS
;-----
G8_B7	LSR	A
	SET_A8
	RTS
;=====
@GET_10BITS	LDX	SRC_BIT_PTR
	SET_A16
	TXA
	ASL	A
	TAX
	SET_A8
	JMP	(G10_JMPS,X)
;-----
G10_B0	LDA	[DCMP_SRC],Y	;GET 1ST BYTE
	XBA
	INY
	LDA	[DCMP_SRC],Y	;GET 2ND BYTE
	AND	#$C0	;MASK OFF THE DATA
	SET_A16
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	LDX	#2
	STX	SRC_BIT_PTR
	RTS
;
	LONGA	OFF
;
;-----
G10_B1	LDA	[DCMP_SRC],Y	;GET 1ST BYTE
	AND	#$7F	;MASK OFF THE DATA
	XBA
	INY
	LDA	[DCMP_SRC],Y	;GET 2ND BYTE
	AND	#$E0	;MASK OFF THE DATA
	SET_A16
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	LDX	#3
	STX	SRC_BIT_PTR
	RTS
;
	LONGA	OFF
;
;-----
G10_B2	LDA	[DCMP_SRC],Y	;GET 1ST BYTE
	AND	#$3F	;MASK OFF THE DATA
	XBA
	INY
	LDA	[DCMP_SRC],Y	;GET 2ND BYTE
	AND	#$F0	;MASK OFF THE DATA
	SET_A16
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	LDX	#4
	STX	SRC_BIT_PTR
	RTS
;
	LONGA	OFF
;
;-----
G10_B3	LDA	[DCMP_SRC],Y	;GET 1ST BYTE
	AND	#$1F	;MASK OFF THE DATA
	XBA
	INY
	LDA	[DCMP_SRC],Y	;GET 2ND BYTE
	AND	#$F8	;MASK OFF THE DATA
	SET_A16
	LSR	A
	LSR	A
	LSR	A
	LDX	#5
	STX	SRC_BIT_PTR
	RTS
;
	LONGA	OFF
;
;-----
G10_B4	LDA	[DCMP_SRC],Y	;GET 1ST BYTE
	AND	#$0F	;MASK OFF THE DATA
	XBA
	INY
	LDA	[DCMP_SRC],Y	;GET 2ND BYTE
	AND	#$FC	;MASK OFF THE DATA
	SET_A16
	LSR	A
	LSR	A
	LDX	#6
	STX	SRC_BIT_PTR
	RTS
;
	LONGA	OFF
;
;-----
G10_B5	LDA	[DCMP_SRC],Y	;GET 1ST BYTE
	AND	#$07	;MASK OFF THE DATA
	XBA
	INY
	LDA	[DCMP_SRC],Y	;GET 2ND BYTE
	AND	#$FE	;MASK OFF THE DATA
	SET_A16
	LSR	A
	LDX	#7
	STX	SRC_BIT_PTR
	RTS
;
	LONGA	OFF
;
;-----
G10_B6	LDA	[DCMP_SRC],Y	;GET 1ST BYTE
	AND	#$03	;MASK OFF THE DATA
	XBA
	INY
	LDA	[DCMP_SRC],Y	;GET 2ND BYTE
	INY
	SET_A16
	LDX	#0
	STX	SRC_BIT_PTR
	RTS
;
	LONGA	OFF
;
;-----
G10_B7	LDA	[DCMP_SRC],Y	;GET 1ST BYTE
	AND	#$01	;MASK OFF THE DATA
	XBA
	INY
	LDA	[DCMP_SRC],Y	;GET 2ND BYTE
	SET_A16
	ASL	A
	STA	TEMP_X
	SET_A8
	INY
	LDA	[DCMP_SRC],Y	;GET 3RD BYTE
	ROL	A
	ROL	A	;MOVE TO BIT 0
	AND	#$01
	SET_A16
	ORA	TEMP_X
	LDX	#1
	STX	SRC_BIT_PTR
	RTS

	MODEND

;------------------
;TEST_HDMA

TEST_HDMA	MODULE

	PHP
	PHB
;-----
	SET_A8
	STZ	HDMAEN	;DISABLE H-DMA
	LDA	#$42	;WRITE 2 BYTES TWICE L,L
	STA	WDMAP7
	LDA	#<BG2HOFS	;WRITE IT HERE
	STA	BADMA7
	LDA	#<HDMA_SLOT0	;ADDRESS TO READ FROM
	STA	A1ADMAL7   	;LOW
	LDA	#>HDMA_SLOT0
	STA	A1ADMAH7	;HIGH
	LDA	#^HDMA_SLOT0
	STA	A1ADMAB7	;BANK
	STA	DMADATB7


;-----
	PLB
	PLP
	RTL

	MODEND

;------------------
;------------------
;------------------
;------------------
;------------------
