;------------------
;
;GG_SCRL.658
;
;  THE SCROLL ROUTINES HANDLE THE REFREASHING OF THE SCREEN EDGES
;AS THE PLAYER'S CHARACTER MOVES AROUND THE GAME MAP
;
;
;------------------

;	SECTION	GG_CODE,?

;------------------
;EQUATES

LATENCY	EQU	8
OVERSPEED	EQU	2
LAG_TIME	EQU	1
X_ERROR	EQU	8
Y_ERROR	EQU	8

;------------------
;SCROLL_OFF -- NO SCROLLING DONE

SCROLL_OFF	MODULE

	RTL

	MODEND

;------------------
;LVL5B_SCROLL -- DO SCROLLING FOR LEVEL 5B

L5BY0	EQU    	56	
L5BY1	EQU	81
L5BY2	EQU	104
L5BY3	EQU	128
L5BY4	EQU	160
L5BY5	EQU	176

L5BZ0	EQU	L5BY0
L5BZ1	EQU	L5BY1-L5BY0
L5BZ2	EQU	L5BY2-L5BY1
L5BZ3	EQU	L5BY3-L5BY2
L5BZ4	EQU	L5BY4-L5BY3
L5BZ5	EQU	L5BY5-L5BY4
L5BZ6	EQU	224-L5BY5

LVL5B_SCROLL	MODULE

	PHP
	PHB
;-----
;DO NORMALL SCROLLING
	JSL	CK_SCROLL	;DO NORMAL SCROLLING
;-----
;NOW SETUP THE H-DMA ON CHANNEL 7 AGAIN
	SET_A8
	LDA	#$42	;WRITE 2 BYTES TWICE L,L
	STA	WDMAP7
	LDA	#<BG2HOFS	;WRITE IT HERE
	STA	BADMA7
	LDA	#<HDMA_SLOT0	;ADDRESS TO READ FROM
	STA	A1ADMAL7   	;LOW
	LDA	#>HDMA_SLOT0
	STA	A1ADMAH7	;HIGH
	LDA	#^HDMA_SLOT0
	STA	A1ADMAB7	;BANK
	STA	DMADATB7
;-----

	SET_A8
	LDA	#L5BZ0	;# OF LINES TO REPEAT
	STA	HDMA_SLOT0
	LDA	#L5BZ1	;# OF LINES TO REPEAT
	STA	HDMA_SLOT1
	LDA	#L5BZ2
	STA	HDMA_SLOT2
	LDA	#L5BZ3
	STA	HDMA_SLOT3
	LDA	#L5BZ4
	STA	HDMA_SLOT4
	LDA	#L5BZ5
	STA	HDMA_SLOT5
;
	SET_A16
	LDA	#<HDMA_DATA	;POINT TO DATA
	STA	HDMA_SLOT0+1
;
	LDA	#<HDMA_DATA+2
	STA	HDMA_SLOT1+1
;
	LDA	#<HDMA_DATA+4
	STA	HDMA_SLOT2+1
;
	LDA	#<HDMA_DATA+6
	STA	HDMA_SLOT3+1
;
	LDA	#<HDMA_DATA+8
	STA	HDMA_SLOT4+1
;
	LDA	#<HDMA_DATA+10
	STA	HDMA_SLOT5+1
;
	LDA	MAP1_X
	LSR	A
	STA	HDMA_DATA+10
	LSR	A
	STA	HDMA_DATA+8
	LSR	A
	STA	HDMA_DATA+6
	LSR	A
	STA	HDMA_DATA+4
	LSR	A
	STA	HDMA_DATA+2
	LSR	A
	STA	HDMA_DATA
;-----
;DO H-DMA
	SET_A8
	LDA	#1
	STA	HDMA_FLAG	;SET UP FOR VBLANK EXECUTION
;-----
@SKIP	PLB
	PLP
	RTL

	MODEND

;------------------
;CK_SCROLL -- CINEMATIC SCROLL ROUTINE

CK_SCROLL	MODULE

	PHP
	SET_AXY16
;-----
          	LDA	MAP1_X	;SET LAST POSITION
	STA	MAP1_LASTX
   	LDA	MAP1_Y	;SET LAST POSITION
	STA	MAP1_LASTY
;-----
;SET THE OPTIMUM Y POSITION
	LDA	OBJ_Y
	SEC
	SBC	#$50	;WHERE IT SHOULD BE IN Y
	BCS	@YOK1
	LDA	#0
@YOK1	CMP	BOTTOM_EDGE1	;OFF BOTTOM EDGE ?
	BLT	@YOK2
	LDA	BOTTOM_EDGE1	;USE BOTTOM EDGE
@YOK2	STA	OPP_MAPY
;-----
;Y ERROR = OPTIMUM Y - CURRENT MAP 1 Y
	SEC
	SBC	MAP1_Y
	STA	ERRORY
	BIT	#$8000	;NEG ?
	BEQ	@YNOTNEG
	EOR	#$FFFF	;MAKE POSITIVE
	INC	A
@YNOTNEG	STA	ABS_ERRY	;THIS IS HOW FAR FROM OPTIMUM THE SCREEN IS IN Y
;-----
;WHAT DIRECTION IS GOLIATH MOVING ?
	SET_A8
	LDA	OBJ_FLIP	;LOOKING RIGHT ?
	BIT	#$40	;REVERSE BIT SET ?
	BNE	@LK_LEFT	;LOOKING LEFT
;-----
@LK_RIGHT	SET_A16
	LDA	OBJ_X	;FIRST SET THE OPTIMUM MAP X POSITION
	SEC		;BASED ON GOLIATH'S POSITION IN THE MAP
	SBC	#$40	;LOOKING RIGHT
	BCS	@RTXOK1	;OFF LEFT EDGE ?
	LDA	#0	;THEN USE LEFT EDGE
@RTXOK1	CMP	RIGHT_EDGE1	;OFF RIGHT EDGE ?
	BLT	@RTXOK2
       	LDA	RIGHT_EDGE1
@RTXOK2	STA	OPP_MAPX
;-----
; X ERROR = OPTIMUM X - CURRENT MAP 1 X
	SEC
	SBC	MAP1_X	;CALC X ERROR
	STA	ERRORX
	BIT	#$8000	;NEG ?
	BEQ	@XNOTNEG2
	EOR	#$FFFF	;MAKE POSITIVE
	INC	A
@XNOTNEG2	STA	ABS_ERRX	;THIS IS HOW FAR FROM OPTIMUM THE SCREEN IS IN X
	JMP	@CK_ERRX
;-----	
@LK_LEFT	SET_A16
	LDA	OBJ_X
	SEC
	SBC	#$80	;LOOKING LEFT
	BCS	@LTXOK1	;OFF LEFT EDGE ?
	LDA	#0	;THEN USE LEFT EDGE
@LTXOK1	CMP	RIGHT_EDGE1	;OFF RIGHT EDGE ?
	BLT	@LTXOK2
       	LDA	RIGHT_EDGE1	;USE RIGHT EDGE THEN
@LTXOK2	STA	OPP_MAPX
;-----
; X ERROR = OPTIMUM X - CURRENT MAP 1 X
	LDA	MAP1_X
	SEC
	SBC	OPP_MAPX	;CALC X ERROR
	STA	ERRORX	;THIS IS HOW FAR FROM OPTIMUM THE SCREEN IS IN X
	BIT	#$8000	;NEG ?
	BEQ	@XNOTNEG1
	EOR	#$FFFF	;MAKE POSITIVE
	INC	A
@XNOTNEG1	STA	ABS_ERRX	;THIS IS HOW FAR FROM OPTIMUM THE SCREEN IS IN X
;-----
;IF ERROR < 8 THEN NO SCROLLING NEEDED
@CK_ERRX	LDA	ABS_ERRX
	CMP	#X_ERROR
	BGE	@DO_XSCROLL	;IF ERRORX <> 0 THEN MUST SCROLL
	LDA	OBJ_DX
	CMP	XSCROLL_RATE	;ARE THEY THE SAME ?
	BGE	@RATE_OK
	JMP	@DO_XDECEL
@RATE_OK	JMP	@NEW_XSCROLL	;AND GO DO THE SCROLL
;-----
;WE NEED TO SCROLL
;FIGURE OUT WHAT THE MAX SCROLL SPEED SHOULD BE
@DO_XSCROLL	LDA	ABS_ERRX	;USE ABSOLUTE VALUE OF ERRORX
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	INC	A	;ERRORX / 32 + 1
	CLC
	ADC	OBJ_DX	;GET DELTA X THIS FRAME
	CMP	#$10	;TOO BIG ?
	BLT	@NEWXMAX_OK
           	LDA	#$10	;DON'T LET IT GO TOO FAST
@NEWXMAX_OK	STA	MAX_XRATE	;SET MAX SPEED
;-----
;IF ERR IS NEG THEN WE HAVE PASSED UP THE OPTIMUM X POSITION
	LDA	ERRORX	;SEE IF ERRORX IS NEG
	BIT	#$8000
	BEQ	@ERR_POS	;POSITIVE ERROR SO GO ACCELERATE
;-----
;IF ERROR IS NEGATIVE AND OBJ_FLIP <> XSCROLL_DIR THEN LET IT ACCELERATE
;TO GET BACK INTO OPTIMUM POSITION
	SET_A8
	LDA	OBJ_FLIP	;GOLIATH'S DIRECTION
	AND	#$40
	CMP	XSCROLL_DIR	;SCROLLING THAT WAY ?
	SET_A16
	BNE	@DO_XACCEL	;NO THEN KEEP ACCELERATING
	JMP	@DO_XDECEL	;YES, LET IT SLOW DOWN

;	BNE	@DO_XDECEL	;WENT PAST SO SLOW DOWN
;-----
;OK TO ACCELERATE AS LONG AS IT'S IN GOLIATH'S DIRECTION
;
@ERR_POS	SET_A8
	LDA	OBJ_FLIP	;ARE WE SCROLLING THE SAME DIR AS GOLIATH ?
	AND	#$40
	CMP	XSCROLL_DIR
	SET_A16
	BNE	@DO_XDECEL	;NO SLOW DOWN AND REVERSE DIR
@DO_XACCEL	LDA	NMI_CTR
	BIT	#LAG_TIME
	BNE	@NEW_XSCROLL	;SET THE NEW MAPX
	LDA	XSCROLL_RATE	;IS X SCROLL AT MAX ?
	CMP	MAX_XRATE
	BEQ	@NEW_XSCROLL	;THEN DON'T ACCEL
	BGE	@MUST_DECEL	;OVER SPEED SO DECEL
@MUST_ACCEL	INC	XSCROLL_RATE	;ACCELERATE
	JMP	@NEW_XSCROLL	;SET THE NEW MAPX
;-----
;WE HAVE GONE PAST GOLIATH'S POSITION
;SINCE WE ARE SCROLLING TO THE LEFT THEN
;DECELERATE TILL ZERO AND GO BACK
;
@DO_XDECEL	LDA	NMI_CTR
	BIT	#LAG_TIME
	BNE	@NEW_XSCROLL	;SET THE NEW MAPX
	LDA	XSCROLL_RATE
	CMP	#0	;AT ZERO NOW ?
	BNE	@MUST_DECEL
	SET_A8
	LDA   	XSCROLL_DIR	;SET NEW DIR
	EOR	#$40
	STA	XSCROLL_DIR
	SET_A16
	JMP	@MUST_ACCEL
@MUST_DECEL	DEC	XSCROLL_RATE	;ACCELERATE
	JMP	@NEW_XSCROLL
;-----
;NOW ADD OR SUB THE XSCROLL_RATE TO MAP1X
@NEW_XSCROLL	SET_A8
	LDA	XSCROLL_DIR
	BIT	#$40
	SET_A16
	BNE	@BACKUP
	CLC
	LDA	MAP1_X
	ADC	XSCROLL_RATE
	CMP	RIGHT_EDGE1	;OVER THE EDGE ?
	BLT	@XREOK
	LDA	RIGHT_EDGE1	;USE RIGHT EDGE
@XREOK	STA	MAP1_X
	JMP	@CK_YSCROLL
;-----
@BACKUP	SEC
	LDA	MAP1_X
	SBC	XSCROLL_RATE
	BCS	@BUXOK
	LDA	#0
@BUXOK	STA	MAP1_X
;-----
;SEE IF WE NEED TO SCROLL IN Y
@CK_YSCROLL	LDA	OPP_MAPY	;IS THE OPTIMUM Y = 0 ?
	BNE	@MUST_Y	;NO SO MUST SCROLL
	STZ	YSCROLL_RATE	;CLEAR SO NO JITTER
	JMP	SCROLL_SCRN	;AT TOP OF SCREEN SO NO SCROLLING
;-----
@MUST_Y	LDA	ABS_ERRY	;GET ABSOULTE VALUE OF ERRORY
	CMP	#Y_ERROR	;ERROR TO LARGE	?
	BGE	@DO_YSCROLL	;IF ERROR TOO BIG THEN MUST SCROLL
	LDA	ABS_DY
	CMP	YSCROLL_RATE	;ARE THEY THE SAME ?
	BGE	@YRATE_OK
	JMP	@DO_YDECEL
@YRATE_OK	JMP	@NEW_YSCROLL	;AND GO DO THE SCROLL
;-----
;WE NEED TO SCROLL
;FIGURE OUT WHAT THE MAX SCROLL SPEED SHOULD BE
@DO_YSCROLL	LDA	ABS_ERRY	;USE ABSOLUTE VALUE OF ERRORY
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	INC	A	;ERRORX / 32 + 1
	CLC
	ADC	ABS_DY	;GET ABSOLUTE VALUE OF DELTA Y THIS FRAME
	CMP	#$10	;TOO BIG ?
	BLT	@NEWYMAX_OK
           	LDA	#$10	;DON'T LET IT GO TOO FAST
@NEWYMAX_OK	STA	MAX_YRATE	;SET MAX SPEED
;-----
	CMP	YSCROLL_RATE	;GET CURRENT RATE
	BLT	@DO_YDECEL	;NO, SLOW DOWN AND REVERSE DIR
@DO_YACCEL	LDA	NMI_CTR
	BIT	#LAG_TIME
	BNE	@NEW_YSCROLL	;SET THE NEW MAPX
	LDA	YSCROLL_RATE	;IS X SCROLL AT MAX ?
	CMP	MAX_YRATE
	BEQ	@NEW_YSCROLL	;THEN DON'T ACCEL
	BGE	@YMUST_DECEL	;OVER SPEED SO DECEL
@YMUST_ACCEL	INC	YSCROLL_RATE	;ACCELERATE
	JMP	@NEW_YSCROLL	;SET THE NEW MAPX
;-----
;WE HAVE GONE PAST GOLIATH'S POSITION
;SINCE WE ARE SCROLLING TO THE LEFT THEN
;DECELERATE TILL ZERO AND GO BACK
;
@DO_YDECEL	LDA	NMI_CTR
	BIT	#LAG_TIME
	BNE	@NEW_YSCROLL	;SET THE NEW MAPX
	LDA	YSCROLL_RATE
	CMP	#0	;AT ZERO NOW ?
	BEQ	@NEW_YSCROLL

;	BNE	@YMUST_DECEL
;	SET_A8
;	LDA   	YSCROLL_DIR	;SET NEW DIR
;	EOR	#$FFFF
;	STA	YSCROLL_DIR
;	SET_A16
;	JMP	@MUST_ACCEL

@YMUST_DECEL	DEC	YSCROLL_RATE	;ACCELERATE
;-----
;NOW ADD OR SUB THE XSCROLL_RATE TO MAP1X
@NEW_YSCROLL	LDA	ERRORY
	BIT	#$8000
	BNE	@YBACKUP
	CLC
	LDA	MAP1_Y
	ADC	YSCROLL_RATE
	CMP	BOTTOM_EDGE1
	BLT	@YBEOK
	LDA	BOTTOM_EDGE1	;SET TO THE BOTTOM
@YBEOK	STA	MAP1_Y
	JMP	SCROLL_SCRN
;-----
@YBACKUP	SEC
	LDA	MAP1_Y
	SBC	YSCROLL_RATE
	BCS	@BUYOK
	LDA	#0
@BUYOK	STA	MAP1_Y
	JMP	SCROLL_SCRN

	MODEND

;------------------
;CK_SCROLL2 -- THIS ROUTINE NEEDS TO RUN AFTER OBJ_HANDLER. IT FOLLOWS
;THE MAIN OBJECT'S X AND Y POSITION. IT THEN CHECK TO SEE IF NEW EDGES
;NEED TO BE DRAWN. THIS IS DONE FOR ALL THE BACKGROUND SCREENS

CK_SCROLL2	MODULE

	PHP
;-----
;SEE IF MAIN OBJECT IS SCROLLING THE SCREEN AROUND
	SET_AXY16
          	LDA	MAP1_X	;SET LAST POSITION
	STA	MAP1_LASTX

;-----
	LDA	OBJ_X
	SEC
	SBC	#$60
	BCS	@SETX
	LDA	#0

@SETX	CMP	RIGHT_EDGE1	;OFF RIGHT EDGE ?
	BGE	@TRY_Y
	STA	MAP1_X
	STA	MAP2_X
;-----
@TRY_Y	LDA	OBJ_Y
	SEC
	SBC	#$50
	BCS	@SETY
	LDA	#0
@SETY	CMP	BOTTOM_EDGE1
	BGE	@DONE
	STA	MAP1_Y
	STA	MAP2_Y
@DONE	JMP	SCROLL_SCRN

	MODEND

;------------------
;CK_SCROLL3 -- THIS ROUTINE NEEDS TO RUN AFTER OBJ_HANDLER. IT FOLLOWS
;THE MAIN OBJECT'S X AND Y POSITION. IT THEN CHECK TO SEE IF NEW EDGES
;NEED TO BE DRAWN. THIS IS DONE FOR ALL THE BACKGROUND SCREENS

CK_SCROLL3	MODULE

	PHP
;-----
;SEE IF MAIN OBJECT IS SCROLLING THE SCREEN AROUND
	SET_AXY16
          	LDA	MAP1_X	;SET LAST POSITION
	STA	MAP1_LASTX
;-----
;SEE WHAT DIRECTION IT POINTED
	LDA	OBJ_FLIP	;GET FLIP DATA
	BIT	#$40	;HORZ FLIP SET ?
	BEQ	@LOOK_RIGHT
	LDA	#$90
	STA	HORZ_BUFFER
	JMP	CK_X_CONT
;-----
@LOOK_RIGHT	LDA	#$30
	STA	HORZ_BUFFER
;
CK_X_CONT	LDA	OBJ_X	;SEE IF ITS OVER ON 
	CMP	HORZ_BUFFER	;THE LEFT SIDE OF MAP
	BGE	@XOK	;NO IT'S IN SCROLL AREA
;
	LDA	MAP1_X	;GET MAP1 X
	CMP	#0	;IS IT SCROLLED ALL THE WAY LEFT ?
	BEQ	CK_UP_DOWN
;
	LDA	MAP1_X
	SEC
	SBC	XSCROLL_RATE	;MOVE LEFT
	BCS	@XOK2
	LDA	#0

@XOK2	STA	MAP1_X
	STA	MAP2_X
	JMP	CK_UP_DOWN
;
@XOK	SEC
	SBC	HORZ_BUFFER  	;THIS SHOULD BE MAP POSITION
	CMP	MAP1_X	;IS IT MAP POSITION
	BEQ	CK_UP_DOWN
	BLT	@MOVE_X_LEFT	;FINAL X < CURRENT X
;
	LDA	MAP1_X
	CLC
	ADC	XSCROLL_RATE
	CMP	RIGHT_EDGE1	;ON RIGHT EDGE ?
	BGE	CK_UP_DOWN
	STA	MAP1_X
	STA	MAP2_X
	JMP	CK_UP_DOWN
;
@MOVE_X_LEFT	LDA	MAP1_X
	SEC
	SBC	XSCROLL_RATE
	STA	MAP1_X
	STA	MAP2_X
;-----
CK_UP_DOWN   	LDA	MAP1_Y	;SET LAST POSITION
	STA	MAP1_LASTY
;
	LDA	OBJ_Y	;SEE IF ITS OVER ON 
	CMP	#$50	;THE BOTTOM SIDE OF MAP
	BGE	@YOK	;NO IT'S IN SCROLL AREA
;
	LDA	MAP1_Y	;GET MAP1 Y
	CMP	#0	;IS IT SCROLLED ALL THE WAY UP ?
	BEQ	END_CK2
;
	LDA	MAP1_Y
	SEC
	SBC	YSCROLL_RATE	;MOVE UP
	BCS	@YOK2
	LDA	#0
@YOK2	STA	MAP1_Y
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	STA	MAP2_Y
END_CK2	JMP	END_CK
;
@YOK	SEC
	SBC	#$50  	;THIS SHOULD BE MAP POSITION

	AND	#$FFFE	;TEST

	CMP	MAP1_Y	;IS IT MAP POSITION
	BEQ	END_CK2
	BLT	@MOVE_Y_UP	;FINAL Y < CURRENT Y
;
	LDA	MAP1_Y
	CLC
	ADC	YSCROLL_RATE
	CMP	BOTTOM_EDGE1	;ON RIGHT EDGE ?
	BGE	END_CK
	STA	MAP1_Y
;-----
	DEC	SCROLL_CTR2
	BNE	END_CK
	LDA	SCROLL_CTR1
	STA	SCROLL_CTR2

@SETIT	LDA	MAP2_Y
	CLC
	ADC	#1
	STA	MAP2_Y
;
	DEC	SCROLL_CTR4
	BNE	END_CK
	LDA	SCROLL_CTR3
	STA	SCROLL_CTR4
;
	LDA	SCROLL_CTR1
	SEC
	SBC	#1
	CMP	#0
	BEQ	END_CK
	STA	SCROLL_CTR1
;
	LDA	SCROLL_CTR3
	CLC
	ADC	#8
	STA	SCROLL_CTR3
	JMP	END_CK
;
@MOVE_Y_UP	LDA	MAP1_Y
	SEC
	SBC	YSCROLL_RATE
	STA	MAP1_Y
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	STA	MAP2_Y
;
END_CK
;-----
;CKECK SCROLL FOR BACKGROUND SCREEN #1
SCROLL_SCRN	SET_A8
	LDA	MAP1_SC_FLAG
	CMP	#2
	BNE	@NO_Y_SCROLL1
	SET_AXY16
	STZ	SCROLL_DIR	;ASSUME RIGHT
	LDA	MAP1_X	;GET CURRENT X
	CMP	MAP1_LASTX	;DID IT MOVE
	BEQ	@NO_X_SCROLL1
	BGE	@WAS_RIGHT1
	LDA	#1
	STA	SCROLL_DIR
;
@WAS_RIGHT1	LDA	MAP1_X
	AND	#$FFF0	;SEE IF WENT OVER A TILE WIDTH
	STA	TEMP_X
	LDA	MAP1_LASTX
	AND	#$FFF0
	CMP	TEMP_X	;SAME TILE POSITION ?
	BEQ	@NO_X_SCROLL1
	LDX	#0	;BACKGROUND 1
	LDY	#0
	JSL	NEW_SIDE_TILE
	SET_A8
	LDA	#1
	STA	HSC_DMA_FLAG1	;SET FLAG TO DO IT
	SET_A16
;-----
@NO_X_SCROLL1	LDA	#3	;ASSUME DOWN
	STA	SCROLL_DIR
	LDA	MAP1_Y
	CMP	MAP1_LASTY
	BEQ	@NO_Y_SCROLL1
	BGE	@WAS_DOWN1
	LDA	#2
	STA	SCROLL_DIR	;MAKE IT UP
;
@WAS_DOWN1	LDA	MAP1_Y
	AND	#$FFF0	;SEE IF WENT OVER A TILE WIDTH
	STA	TEMP_Y
	LDA	MAP1_LASTY
	AND	#$FFF0
	CMP	TEMP_Y	;SAME TILE POSITION ?
	BEQ	@NO_Y_SCROLL1
	LDX	#0	;BACKGROUND 1
	LDY	#0
	JSL	NEW_VERT_TILE
	SET_A8
	LDA	#1
	STA	VSC_DMA_FLAG1	;SET FLAG TO DO IT
@NO_Y_SCROLL1	SET_A16
	LDA	MAP1_X
	STA	MAP1_LASTX	;RESET X
	LDA	MAP1_Y
	STA	MAP1_LASTY	;RESET Y
;-----
;CKECK SCROLL FOR BACKGROUND SCREEN #2
	SET_A8
	LDA	MAP2_SC_FLAG	;CAN MAP2 SCROLL ?
	CMP	#2
	BNE	@NO_Y_SCROLL2
	SET_A16
	STZ	SCROLL_DIR	;ASSUME RIGHT
	LDA	MAP2_X	;GET CURRENT X
	CMP	MAP2_LASTX	;DID IT MOVE
	BEQ	@NO_X_SCROLL2
	BGE	@WAS_RIGHT2
	LDA	#1
	STA	SCROLL_DIR
;
@WAS_RIGHT2	LDA	MAP2_X
	AND	#$FFF0	;SEE IF WENT OVER A TILE WIDTH
	STA	TEMP_X
	LDA	MAP2_LASTX
	AND	#$FFF0
	CMP	TEMP_X	;SAME TILE POSITION ?
	BEQ	@NO_X_SCROLL2
	LDX	#2	;BACKGROUND 2
	LDY	#3
	JSL	NEW_SIDE_TILE
	SET_A8
	LDA	#1
	STA	HSC_DMA_FLAG2	;SET FLAG TO DO IT
	SET_A16
;-----
@NO_X_SCROLL2	LDA	#3	;ASSUME DOWN
	STA	SCROLL_DIR
	LDA	MAP2_Y
	CMP	MAP2_LASTY
	BEQ	@NO_Y_SCROLL2
	BGE	@WAS_DOWN2
	LDA	#2
	STA	SCROLL_DIR	;MAKE IT UP
;
@WAS_DOWN2	LDA	MAP2_Y
	AND	#$FFF0	;SEE IF WENT OVER A TILE WIDTH
	STA	TEMP_Y
	LDA	MAP2_LASTY
	AND	#$FFF0
	CMP	TEMP_Y	;SAME TILE POSITION ?
	BEQ	@NO_Y_SCROLL2
	LDX	#2	;BACKGROUND 2
	LDY	#3
	JSL	NEW_VERT_TILE
	SET_A8
	LDA	#1
	STA	VSC_DMA_FLAG2	;SET FLAG TO DO IT
@NO_Y_SCROLL2	SET_A16
	LDA	MAP2_X
	STA	MAP2_LASTX	;RESET X
	LDA	MAP2_Y
	STA	MAP2_LASTY	;RESET Y
;-----
;CKECK SCROLL FOR BACKGROUND SCREEN #3
	SET_A8
	LDA	MAP3_SC_FLAG
	CMP	#2
	BNE	@NO_Y_SCROLL3
	SET_A16
	STZ	SCROLL_DIR	;ASSUME RIGHT
	LDA	MAP3_X	;GET CURRENT X
	CMP	MAP3_LASTX	;DID IT MOVE
	BEQ	@NO_X_SCROLL3
	BGE	@WAS_RIGHT3
	LDA	#1
	STA	SCROLL_DIR
;
@WAS_RIGHT3	LDA	MAP3_X
	AND	#$FFF0	;SEE IF WENT OVER A TILE WIDTH
	STA	TEMP_X
	LDA	MAP3_LASTX
	AND	#$FFF0
	CMP	TEMP_X	;SAME TILE POSITION ?
	BEQ	@NO_X_SCROLL3
	LDX	#4	;BACKGROUND 3
	LDY	#6
	JSL	NEW_SIDE_TILE
;-----
@NO_X_SCROLL3	LDA	#3	;ASSUME DOWN
	STA	SCROLL_DIR
	LDA	MAP3_Y
	CMP	MAP3_LASTY
	BEQ	@NO_Y_SCROLL3
	BGE	@WAS_DOWN3
	LDA	#2
	STA	SCROLL_DIR	;MAKE IT UP
;
@WAS_DOWN3	LDA	MAP3_Y
	AND	#$FFF0	;SEE IF WENT OVER A TILE WIDTH
	STA	TEMP_Y
	LDA	MAP3_LASTY
	AND	#$FFF0
	CMP	TEMP_Y	;SAME TILE POSITION ?
	BEQ	@NO_Y_SCROLL3
	LDX	#4	;BACKGROUND 3
	LDY	#6
	JSL	NEW_VERT_TILE
@NO_Y_SCROLL3	SET_A16
	LDA	MAP3_X
	STA	MAP3_LASTX	;RESET X
	LDA	MAP3_Y
	STA	MAP3_LASTY	;RESET Y
;-----
	PLP
	RTL

	MODEND

;------------------
;LVL5A_SCROLL -- SPECIAL SCROLL ROUTINE FOR DESCENT PART 1


;OFFSET_TABLE	DW	0,0,0,0,0,0,0,0
;	DW	0,0,0,0,0,0,0,0
;	DW	0,0,0,0,0,0,0,0
;	DW	0,0,0,0,0,0,0,0
;
;VERT_SHEAR	DW	0,$2000,$2000,$2000,$2000,0,0,0
;	DW	0,0,0,0,0,0,0,0
;	DW	0,0,0,0,0,0,0,0
;	DW	0,0,0,0,0,0,0,0


LVL5A_SCROLL	MODULE

	PHP
	PHB
	SET_A8
	LDA	#^VERT_SHEAR
	PHA
	PLB
;-----
;SEE IF MAIN OBJECT IS SCROLLING THE SCREEN AROUND
	SET_AXY16
	LDA	MAP1_Y
	CLC
	ADC	#4
	STA	MAP1_Y
;
	LDA	SHEAR1_Y
	CLC
	ADC	#3
	AND	#$03FF
	STA	SHEAR1_Y
;
	LDA	SHEAR2_Y
	CLC
	ADC	#2
	AND	#$03FF
	STA	SHEAR2_Y

	LDA	MAP1_Y
	LSR	A
	LSR	A
	STA	TEMP_Y
	LSR	A
	STA	TEMP_X

	LDA	MAP1_Y
	SEC
	SBC	TEMP_X
	STA	SHEAR1_Y
	
	LDA	MAP1_Y
	SEC
	SBC	TEMP_Y
	STA	SHEAR2_Y
	



	LDA	SHEAR1_Y	
	ORA	#$2000
	STA	VERT_SHEAR+2
	STA	VERT_SHEAR+4
	STA	VERT_SHEAR+6
	STA	VERT_SHEAR+8
	STA	VERT_SHEAR+50
	STA	VERT_SHEAR+52
	STA	VERT_SHEAR+54
	STA	VERT_SHEAR+56

	LDA	SHEAR2_Y
	ORA	#$2000
	STA	VERT_SHEAR+10
	STA	VERT_SHEAR+12
	STA	VERT_SHEAR+46
	STA	VERT_SHEAR+48




;-----
;	DEC	SCROLL_CTR2
;	BNE	@END_CK
;	LDA	SCROLL_CTR1
;	STA	SCROLL_CTR2

@SETIT	LDA	MAP2_Y
	CLC
	ADC	#1
	STA	MAP2_Y
;
	DEC	SCROLL_CTR4
	BNE	@END_CK
	LDA	SCROLL_CTR3
	STA	SCROLL_CTR4
;
	LDA	SCROLL_CTR1
	SEC
	SBC	#1
	CMP	#0
	BEQ	@END_CK
	STA	SCROLL_CTR1
;
	LDA	SCROLL_CTR3
	CLC
	ADC	#8
	STA	SCROLL_CTR3
@END_CK
;-----
;CKECK SCROLL FOR BACKGROUND SCREEN #2
	SET_A8
	LDA	MAP2_SC_FLAG	;CAN MAP2 SCROLL ?
	CMP	#2
	BNE	@NO_Y_SCROLL2
	SET_A16
	LDA	#3	;ASSUME DOWN
	STA	SCROLL_DIR
;	LDA	MAP2_Y
;	CMP	MAP2_LASTY
;	BEQ	@NO_Y_SCROLL2
;	BGE	@WAS_DOWN2
;	LDA	#2
;	STA	SCROLL_DIR	;MAKE IT UP
;
@WAS_DOWN2	LDA	MAP2_Y
	AND	#$FFF0	;SEE IF WENT OVER A TILE WIDTH
	STA	TEMP_Y
	LDA	MAP2_LASTY
	AND	#$FFF0
	CMP	TEMP_Y	;SAME TILE POSITION ?
	BEQ	@NO_Y_SCROLL2
	LDX	#2	;BACKGROUND 2
	LDY	#3
	JSL	NEW_VERT_TILE
	SET_A8
	LDA	#1
	STA	VSC_DMA_FLAG2	;SET FLAG TO DO IT
	SET_A16
@NO_Y_SCROLL2	LDA	MAP2_X
	STA	MAP2_LASTX	;RESET X
	LDA	MAP2_Y
	STA	MAP2_LASTY	;RESET Y
;-----
;NOW SETUP THE DMA DATA ON THE DMA_HEAP
CK_HERE	SET_AXY16
	LDX	DMA_HEAP_PTR	;GET PTR
	SET_A8
	LDA	#^DMA_HEAP
	PHA
	PLB		;SET BANK OF DMA_HEAP
	LDA	#2	;SINGLE DMA
	STA	DMA_HEAP,X
	INX
;
	LDA	#$80	;VMAINC
	STA	DMA_HEAP,X
	INX
;
	SET_A16
	LDA	#<VERT_SHEAR	;OFFSET
	STA	DMA_HEAP,X
	INX
	INX
;
	SET_A8
	LDA	#^VERT_SHEAR	;BANK
	STA	DMA_HEAP,X
	INX
;
	SET_A16
	LDA	BG3_SC	;DEST OFFSET
	CLC
	ADC	#64/2
	STA	DMA_HEAP,X
	INX
	INX
;
	LDA	#$40	;# OF BYTES
	STA	DMA_HEAP,X
	INX
	INX
	STZ	DMA_HEAP,X	;END OF DMA_HEAP
	STX	DMA_HEAP_PTR	;SAVE PTR
;
	SET_A8
	LDA	#1
	STA	VRAM_DMA_FLAG	;FORCE DMA
;-----
	PLB
	PLP
	RTL

	MODEND

;------------------
;MOVE_RIGHT -- SCROLL SCREEN TO LEFT WHILE MOVING RIGHT
;FILL THE RIGHT EDGE WITH NEW DATA

MOVE_RIGHT	MODULE

	PHP
;-----
	SET_A8
	LDA	MAP1_SC_FLAG	;CAN I SCROLL HERE
	BEQ	NO_SCROLL
	SET_A16
	CLC
	LDA	MAP1_X	;GET CURRENT SCROLL X
	CMP	RIGHT_EDGE1
	BGE	NO_SCROLL
	STA	MAP1_LASTX
	STA	MAP2_LASTX
	ADC	XSCROLL_RATE
	STA	MAP1_X
	STA	MAP2_X
;-----
NO_SCROLL	PLP
NULL_SCROLL	RTL
	
	MODEND

;------------------
;MOVE_LEFT -- SCROLL SCREEN TO RIGHT WHILE MOVING LEFT
;FILL THE LEFT EDGE WITH NEW DATA

MOVE_LEFT	MODULE

	PHP
;-----
	SET_A8
	LDA	MAP1_SC_FLAG	;CAN I SCROLL HERE
	BEQ	NO_SCROLL
	SET_A16
	SEC
	LDA	MAP1_X	;GET CURRENT SCROLL X
	BEQ	NO_SCROLL
	STA	MAP1_LASTX
	STA	MAP2_LASTX
	SBC	XSCROLL_RATE
	STA	MAP1_X
	STA	MAP2_X
;-----
	PLP
	RTL

	MODEND


;------------------
;MOVE_DOWN -- SCROLL SCREEN UP WHILE MOVING DOWN
;FILL THE BOTTOM EDGE WITH NEW DATA

MOVE_DOWN	MODULE

	PHP
;-----
	SET_A8
	LDA	MAP1_SC_FLAG	;CAN I SCROLL HERE
	BEQ	NO_SCROLL2
	SET_A16
	CLC
	LDA	MAP1_Y	;GET CURRENT SCROLL Y
	CMP	BOTTOM_EDGE1
	BGE	NO_SCROLL2
	STA	MAP1_LASTY
	STA	MAP2_LASTY
	ADC	YSCROLL_RATE
	STA	MAP1_Y
	STA	MAP2_Y
;-----
	LDA	OBJ_Y
	CLC
	ADC	YSCROLL_RATE
	STA	OBJ_Y
;-----
	PLP
	RTL

	MODEND

;------------------
;MOVE_UP -- SCROLL SCREEN DOWN WHILE MOVING UP
;FILL THE TOP EDGE WITH NEW DATA

MOVE_UP	MODULE

	PHP
;-----
	SET_A8
	LDA	MAP1_SC_FLAG	;CAN I SCROLL HERE
	BEQ	NO_SCROLL2
	SET_A16
	SEC
	LDA	MAP1_Y	;GET CURRENT SCROLL Y
	BEQ	NO_SCROLL2
	STA	MAP1_LASTY
	STA	MAP2_LASTY
	SBC	YSCROLL_RATE
	STA	MAP1_Y
	STA	MAP2_Y
;-----
	LDA	OBJ_Y
	SEC
	SBC	YSCROLL_RATE
	STA	OBJ_Y
;-----
NO_SCROLL2	PLP
	RTL

	MODEND

;------------------
;NEW_SIDE_TILE -- DRAW NEW TILE ON RIGHT OR LEFT SIDE OF SCREEN
;
;1) FIGURE OUT WHERE THE MAP DATA IS
;2) WRITE THE NEW TILE DATA OUT TO THE SCRN_BUF
;	BYTE 0-63 = TOP LEFT COLUMN
;	BYTE 64-127 = TOP RIGHT COLUMN
;	BYTE 128-191 = BOTTOM LEFT COLUMN
;	BYTE 192-255 = BOTTOM RIGHT COLUMN
;3) FIGURE OUT WHERE IN SCREEN VRAM TO DMA THE DATA

;-----

SCROLL_TABLE1	DW	$00,$02,$04,$06,$08,$0A,$0C,$0E
	DW	$10,$12,$14,$16,$18,$1A,$1C,$1E
	DW	$400,$402,$404,$406,$408,$40A,$40C,$40E
	DW	$410,$412,$414,$416,$418,$41A,$41C,$41E

SCROLL_TABLE2	DW	0,64,2*64,3*64,4*64,5*64,6*64,7*64
	DW	8*64,9*64,10*64,11*64,12*64,13*64,14*64,15*64
	DW	$800,$840,$880,$8C0,$900,$940,$980,$9C0	
	DW	$A00,$A40,$A80,$AC0,$B00,$B40,$B80,$BC0

SCROLL_TABLE3	DW	$00,$40,$80,$C0,$100,$140,$180,$1C0
	DW	$200,$240,$280,$2C0,$300,$340,$380,$3C0
	DW	$800,$840,$880,$8C0,$900,$940,$980,$9C0
	DW	$A00,$A40,$A80,$AC0,$B00,$B40,$B80,$BC0
;-----


NEW_SIDE_TILE	MODULE

	PHP
	SET_AXY16
;-----
	PHX		;SAVE SCREEN INDEX
	LDA	MAP1_X,X	;GET X
	STA	SC_X
	LDA	MAP1_Y,X	;GET Y
	STA	SC_Y
	LDA	MAP1_WIDTH,X	;GET WIDTH
	STA	SC_WIDTH
	LDA	MAP1_IN_RAM,Y	;GET OFFSET OF MAP
	STA	SC_MAP_ADD
	LDA	BLK1_IN_RAM,Y	;GET OFFSET OF BLOCK
	STA	SC_BLK_ADD
	LDA	BG1_SC,X	;GET SCREEN ADDRESS
	STA	BG_SC_ADD
	SET_A8
	LDA	MAP1_IN_RAM+2,Y	;GET BANK OF MAP
	STA	SC_MAP_ADD+2
	LDA	BLK1_IN_RAM+2,Y	;GET BANK OF BLOCK
	STA	SC_BLK_ADD+2
	SET_A16
	TXA
	XBA
	STA	SC_DEST	
;-----
	LDA	SCROLL_DIR
	CMP	#1
	BEQ	@MOVE_LEFT
	LDA	SC_X
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;MAP_X / 16
	CLC
	ADC	#16	;POINT TO NEW MAP LOCATION
          	JMP	@CONT10
;-----
@MOVE_LEFT	SET_AXY16
	LDA	SC_X
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;MAP_X / 16
	SEC
;	SBC	#1	;POINT TO NEW MAP LOCATION
;-----
@CONT10
;	ASL	A
	TAY
	LDA	SC_Y	;CURRENT Y
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;MAP1_Y/16
	AND	#$FFF0	;ROUND TO A SCREEN TOP
	LDX	SC_WIDTH	;GET WIDTH
	JSL	CALC_OFF	;CALCULATE THE MAP OFFSET OF NEW DATA
;-----
;NOW SETUP THE SCRN_BUF AND THE ZERO PAGE POINTERS
	LDA	SC_MAP_ADD	;GET MAP OFFSET
	STA	MAP_IN_RAM
	LDA	SC_BLK_ADD	;GET BLOCK OFFSET
	STA	BLK_IN_RAM
	SET_A8
	LDA	SC_MAP_ADD+2	;GET MAP BANK
	STA	MAP_IN_RAM+2
	LDA	SC_BLK_ADD+2	;GET BLOCK BANK
	STA	BLK_IN_RAM+2
	LDA	#^SCRN_BUF
	PHA
	PLB		;SET SCRN_BUF BANK
;-----
;NOW MAKE THE TILE DATA FROM THE MAP AND BLOCK FOR THE TWO FAR RIGHT ROWS
	SET_A16
;
	LDX	SC_DEST	;START NEW ROW
	LDA    	#32
	STA	SCRN_HEIGTH	;SET COUNTER
;
@LOOP1	LDY	MAP_OFF	;FROM MAP
	LDA	[MAP_IN_RAM],Y	;GET A MAP REFERENCE
	TAY
	AND	#$3C00
	STA	MAP_PC	;SAVE PRIORITY AND COLOR
	TYA
	AND	#$C000
	STA	MAP_FB	;SAVE FLIP BITS
	TYA
	AND	#$03FF	;JUST INDEX DATA
	ASL
	ASL
;-----
;LOOK FOR OBJECTS HERE ?


;-----
	ASL
	TAY		;POINT INTO BLOCK DATA
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY

;	LDA	#1

	STA	T0	;SAVE TILE 0
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY

;	LDA	#1

	STA	T1	;SAVE TILE 1
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY

;	LDA	#1

	STA	T2	;SAVE TILE 2
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS

;	LDA	#1

	STA	T3	;SAVE TILE 3
;-----
;TEST FLIP BITS AND ADJUST
	LDA	MAP_FB	;GET FLIP BITS
	BIT	#$4000	;X FLIP ?
	BEQ	@NO_X_FLIP
	LDA	T0
	LDY	T1
	STA	T1
	STY	T0	;FLIP T0,T1
	LDA	T2
	LDY	T3
	STA	T3
	STY	T2	;FLIP T2,T3
;
@NO_X_FLIP	LDA	MAP_FB	;GET FLIP BITS
	BIT	#$8000	;Y FLIP ?
	BEQ	@NO_Y_FLIP
	LDA	T0
	LDY	T2
	STA	T2
	STY	T0	;FLIP T0,T2
	LDA	T1
	LDY	T3
	STA	T3
	STY	T1	;FLIP T1,T3
;-----
;NOW STORE IT IN THE CORRECT LOCATION IN THE SCRN_BUF
@NO_Y_FLIP	LDA	T0
	STA	SCRN_BUF,X	;SAVE TOP LEFT TILE
	LDA	T1
	STA	SCRN_BUF+128,X	;SAVE TOP RIGHT TILE
	LDA	T2
	STA	SCRN_BUF+2,X	;SAVE BOTTOM LEFT
	LDA	T3
	STA	SCRN_BUF+130,X	;SAVE BOTTOM RIGHT
	INX
	INX
	INX
	INX
;-----
	DEC	SCRN_HEIGTH
	BEQ	@EDGE_DONE
	CLC
	LDA	MAP_OFF	;GET START OF THIS ROW
	ADC	SC_WIDTH	;MAP_WIDTH
	ADC	SC_WIDTH	;MAP_WIDTH	;NEXT MAP ROW
	STA	MAP_OFF
	JMP	@LOOP1
@EDGE_DONE
;-----
;FIGURE OUT WHERE TO PUT IT ON THE SCREEN IN VRAM
	SET_A8
	LDA	#^SCROLL_TABLE1
	PHA
	PLB
	SET_A16
	PLY		;GET SCREEN INDEX
	LDA	#0
	STA	HSC_DMA_TOP1,Y
	LDA	#$800
	STA	HSC_DMA_BTM1,Y
	LDA	SC_Y
	BIT	#$0100	;WHICH QUADRENT OF THE SCROLL SCREENS?
	BEQ	@WAS_ZERO
	LDA	#$800
	STA	HSC_DMA_TOP1,Y	;REVERSE QUADS
	LDA	#0
	STA	HSC_DMA_BTM1,Y
;
@WAS_ZERO	LDA	SCROLL_DIR
	CMP	#1	;SCROLL LEFT ?
	BEQ	@MOVE_LEFT2
	LDA	SC_X	;GET SCROLL X
	LSR	A
	LSR	A
	LSR	A
	LSR	A	; / 16
	CLC
	ADC	#16	;JUST OFF RIGHT EDGE
	JMP	@CONT20
;-----
@MOVE_LEFT2	SET_A16
	LDA	SC_X	;GET SCROLL X
	LSR	A
	LSR	A
	LSR	A
	LSR	A	; / 16
	SEC
;	SBC	#1	;JUST OFF LEFT EDGE
;-----

@CONT20	AND	#$1F
	ASL	A
	TAX
	LDA	SCROLL_TABLE1,X
	CLC	
	ADC	BG_SC_ADD
	TAX		;SAVE IT
	CLC
	ADC	HSC_DMA_TOP1,Y	;ADD Y NOW
	STA	HSC_DMA_TOP1,Y	;SET DESTINATION
	TXA		;RESTORE
	CLC
	ADC	HSC_DMA_BTM1,Y
	STA	HSC_DMA_BTM1,Y	;SET BOTTOM DMA
;-----
	PLP
	RTL

	MODEND

;------------------
;NEW_VERT_TILE -- DRAW NEW TILE ON TOP OR BOTTOM OF SCREEN
;
;1) FIGURE OUT WHERE THE MAP DATA IS
;2) WRITE THE NEW TILE DATA OUT TO THE SCRN_BUF
;	BYTE 0-63 = TOP LEFT COLUMN
;	BYTE 64-127 = TOP RIGHT COLUMN
;	BYTE 128-191 = BOTTOM LEFT COLUMN
;	BYTE 192-255 = BOTTOM RIGHT COLUMN
;3) FIGURE OUT WHERE IN SCREEN VRAM TO DMA THE DATA

NEW_VERT_TILE	MODULE

	PHP
	SET_AXY16
;-----
	PHX		;SAVE SCREEN INDEX
	LDA	MAP1_X,X	;GET X
	STA	SC_X
	LDA	MAP1_Y,X	;GET Y
	STA	SC_Y
	LDA	MAP1_WIDTH,X	;GET WIDTH
	STA	SC_WIDTH
	LDA	MAP1_IN_RAM,Y	;GET OFFSET OF MAP
	STA	SC_MAP_ADD
	LDA	BLK1_IN_RAM,Y	;GET OFFSET OF BLOCK
	STA	SC_BLK_ADD
	LDA	BG1_SC,X	;GET SCREEN ADDRESS
	STA	BG_SC_ADD
	SET_A8
	LDA	MAP1_IN_RAM+2,Y	;GET BANK OF MAP
	STA	SC_MAP_ADD+2
	LDA	BLK1_IN_RAM+2,Y	;GET BANK OF BLOCK
	STA	SC_BLK_ADD+2
	SET_A16	
	TXA
	XBA
	STA	SC_DEST	;DEST IN SCRN_BUF
;-----
	LDA	SCROLL_DIR
	CMP	#2
	BEQ	@MOVE_UP
	LDA	SC_Y
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;MAP_Y / 16
	CLC
	ADC	#16	;POINT TO NEW MAP LOCATION
          	JMP	@CONT10
;-----
@MOVE_UP	SET_AXY16
	LDA	SC_Y
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;MAP_Y / 16
	SEC
;	SBC	#1	;POINT TO NEW MAP LOCATION
;-----
@CONT10	PHA
	LDA	SC_X	;CURRENT X
	LSR	A
	LSR	A
	LSR	A
	LSR	A	;MAP1_Y/16
	AND	#$FFF0	;ROUND TO A SCREEN TOP
;	ASL	A
	TAY
	PLA
	LDX	SC_WIDTH	;GET WIDTH
	JSL	CALC_OFF	;CALCULATE THE MAP OFFSET OF NEW DATA
;-----
;NOW SETUP THE SCRN_BUF AND THE ZERO PAGE POINTERS
	LDA	SC_MAP_ADD	;GET MAP OFFSET
	STA	MAP_IN_RAM
	LDA	SC_BLK_ADD	;GET BLOCK OFFSET
	STA	BLK_IN_RAM
	SET_A8
	LDA	SC_MAP_ADD+2	;GET MAP BANK
	STA	MAP_IN_RAM+2
	LDA	SC_BLK_ADD+2	;GET BLOCK BANK
	STA	BLK_IN_RAM+2
	LDA	#^SCRN_BUF
	PHA
	PLB		;SET SCRN_BUF BANK
;-----
;NOW MAKE THE TILE DATA FROM THE MAP AND BLOCK FOR THE TWO FAR RIGHT ROWS
	SET_A16
;
	LDX	SC_DEST	;START NEW ROW
	LDA    	#32
	STA	SCRN_WIDTH	;SET COUNTER
;
@LOOP1	LDY	MAP_OFF	;FROM MAP
	LDA	[MAP_IN_RAM],Y	;GET A MAP REFERENCE
	TAY
	AND	#$3C00
	STA	MAP_PC	;SAVE PRIORITY AND COLOR
	TYA
	AND	#$C000
	STA	MAP_FB	;SAVE FLIP BITS
	TYA
	AND	#$03FF	;JUST INDEX DATA
	ASL
	ASL
;-----
;LOOK FOR OBJECT INFO HERE ?

;-----
	ASL
	TAY		;POINT INTO BLOCK DATA
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY

;	LDA	#1

	STA	T0	;SAVE TILE 0
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY

;	LDA	#1

	STA	T1	;SAVE TILE 1
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS
	INY
	INY

;	LDA	#1

	STA	T2	;SAVE TILE 2
	LDA	[BLK_IN_RAM],Y
	ORA	MAP_PC	;ADD PRIORITY AND COLOR
	EOR	MAP_FB	;ADD FLIP BITS

;	LDA	#1

	STA	T3	;SAVE TILE 3
;-----
;TEST FLIP BITS AND ADJUST
	LDA	MAP_FB	;GET FLIP BITS
	BIT	#$4000	;X FLIP ?
	BEQ	@NO_X_FLIP
	LDA	T0
	LDY	T1
	STA	T1
	STY	T0	;FLIP T0,T1
	LDA	T2
	LDY	T3
	STA	T3
	STY	T2	;FLIP T2,T3
;
@NO_X_FLIP	LDA	MAP_FB	;GET FLIP BITS
	BIT	#$8000	;Y FLIP ?
	BEQ	@NO_Y_FLIP
	LDA	T0
	LDY	T2
	STA	T2
	STY	T0	;FLIP T0,T2
	LDA	T1
	LDY	T3
	STA	T3
	STY	T1	;FLIP T1,T3
;-----
;NOW STORE IT IN THE CORRECT LOCATION IN THE SCRN_BUF
@NO_Y_FLIP	LDA	T0
	STA	SCRN_BUF+$100,X	;SAVE TOP LEFT TILE
	LDA	T1
	STA	SCRN_BUF+$102,X	;SAVE TOP RIGHT TILE
	LDA	T2
	STA	SCRN_BUF+$140,X	;SAVE BOTTOM LEFT
	LDA	T3
	STA	SCRN_BUF+$142,X	;SAVE BOTTOM RIGHT
	INX
	INX
	INX
	INX
;-----
	DEC	SCRN_WIDTH
	BEQ	@EDGE_DONE
	CLC
	LDA	MAP_OFF	;GET START OF THIS ROW
	ADC	#2
	STA	MAP_OFF
	LDA	SCRN_WIDTH
	CMP	#$10
	BEQ	@SCRN2
	JMP	@LOOP1
@SCRN2	CLC
	LDA	SC_DEST	;GET ORIGINAL DESTINATION
	ADC	#$80
	TAX
	JMP	@LOOP1
@EDGE_DONE
;-----
;FIGURE OUT WHERE TO PUT IT ON THE SCREEN IN VRAM
	SET_A8
	LDA	#^SCROLL_TABLE3
	PHA
	PLB
	SET_A16
	PLY		;GET SCREEN INDEX
	LDA	#0
	STA	VSC_DMA_LEFT1,Y
	LDA	#$400
	STA	VSC_DMA_RHT1,Y
	LDA	SC_X
	BIT	#$0100	;WHICH QUADRENT OF THE SCROLL SCREENS?
	BEQ	@WAS_ZERO
	LDA	#$400
	STA	VSC_DMA_LEFT1,Y	;REVERSE QUADS
	LDA	#0
	STA	VSC_DMA_RHT1,Y
;
@WAS_ZERO	LDA	SCROLL_DIR
	CMP	#2	;SCROLL UP ?
	BEQ	@MOVE_UP2
	LDA	SC_Y	;GET SCROLL X
	LSR	A
	LSR	A
	LSR	A
	LSR	A	; / 16
	CLC
	ADC	#16	;JUST OFF BOTTOM EDGE
	JMP	@CONT20
;-----
@MOVE_UP2	SET_A16
	LDA	SC_Y	;GET SCROLL X
	LSR	A
	LSR	A
	LSR	A
	LSR	A	; / 16
	SEC
;	SBC	#1	;JUST OFF LEFT EDGE
;-----

@CONT20	AND	#$1F
	ASL	A
	TAX
	LDA	SCROLL_TABLE3,X
	CLC	
	ADC	BG_SC_ADD
	TAX		;SAVE IT
	CLC
	ADC	VSC_DMA_LEFT1,Y
	STA	VSC_DMA_LEFT1,Y	;SET DESTINATION
	TXA		;RESTORE
	CLC
	ADC	VSC_DMA_RHT1,Y
	STA	VSC_DMA_RHT1,Y	;SET RIGHT DMA
;-----
	PLP
	RTL

	MODEND

;------------------
;INIT_SCRL5 -- SETUP SCROLL DATA FOR ASCENT

INIT_SCRL5	MODULE

	PHP
	SET_AXY16
;-----
	LDA	#8
	STA	SCROLL_CTR1
	STA	SCROLL_CTR2
	LDA	#32
	STA	SCROLL_CTR3
	STA	SCROLL_CTR4
;
	LDA	MAP1_Y
	STA	SHEAR1_Y
	STA	SHEAR2_Y
;-----
	SET_A8	
	LDA	#1
	STA	GOL_CON_FLAG	;LET IT FALL
;-----
	PLP
	RTL

	MODEND

;------------------

KRAP	MODULE

;-----

	SET_A8
	LDA	#$80+80
	STA	HDMA_SLOT0,X
	SET_A16
	LDA	#<HDMA_DATA
	TAX
	STA	HDMA_SLOT0+1
	LDA	MAP1_X
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	LDY	#0
@LP1	STA	$0,X
	INX
	INX
	INY
	CPY	#80
	BNE	@LP1
;
	SET_A8
	LDA	#$80+40
	STA	HDMA_SLOT1
	SET_A16
	TXA
	STA	HDMA_SLOT1+1
	LDY	#0
	LDA	MAP1_X
	LSR	A
	LSR	A
	LSR	A
@LP2	STA	$0,X
	INX
	INX
	INY
	CPY	#40
	BNE	@LP2
;
	SET_A8
	LDA	#$80+24
	STA	HDMA_SLOT2
	SET_A16
	TXA
	STA	HDMA_SLOT2+1
	LDY	#0
	LDA	MAP1_X
	LSR	A
	LSR	A
@LP3	STA	$0,X
	INX
	INX
	INY
	CPY	#24
	BNE	@LP3



;
	MODEND

;------------------
;------------------
;------------------
;------------------
;------------------
;------------------
;------------------
;------------------
	
